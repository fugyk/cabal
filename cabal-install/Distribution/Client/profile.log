SCRIPT  /Users/Vishal/.vim_runtime/vimrcs/basic.vim
Sourced 1 time
Total time:   0.118025
 Self time:   0.004467

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Maintainer: 
                            "       Amir Salihefendic
                            "       http://amix.dk - amix@amix.dk
                            "
                            " Version: 
                            "       5.0 - 29/05/12 15:43:36
                            "
                            " Blog_post: 
                            "       http://amix.dk/blog/post/19691#The-ultimate-Vim-configuration-on-Github
                            "
                            " Awesome_version:
                            "       Get this config, nice color schemes and lots of plugins!
                            "
                            "       Install the awesome version from:
                            "
                            "           https://github.com/amix/vimrc
                            "
                            " Syntax_highlighted:
                            "       http://amix.dk/vim/vimrc.html
                            "
                            " Raw_version: 
                            "       http://amix.dk/vim/vimrc.txt
                            "
                            " Sections:
                            "    -> General
                            "    -> VIM user interface
                            "    -> Colors and Fonts
                            "    -> Files and backups
                            "    -> Text, tab and indent related
                            "    -> Visual mode related
                            "    -> Moving around, tabs and buffers
                            "    -> Status line
                            "    -> Editing mappings
                            "    -> vimgrep searching and cope displaying
                            "    -> Spell checking
                            "    -> Misc
                            "    -> Helper functions
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => General
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Sets how many lines of history VIM has to remember
    1              0.000010 set history=700
                            
                            " Enable filetype plugins
    1              0.000122 filetype plugin on
    1              0.000167 filetype indent on
                            
                            " Set to auto read when a file is changed from the outside
    1              0.000006 set autoread
                            
                            " With a map leader it's possible to do extra key combinations
                            " like <leader>w saves the current file
    1              0.000004 let mapleader = ","
    1              0.000002 let g:mapleader = ","
                            
                            " Fast saving
    1              0.000015 nmap <leader>w :w!<cr>
                            
                            " :W sudo saves the file 
                            " (useful for handling the permission-denied error)
    1              0.000006 command W w !sudo tee % > /dev/null
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => VIM user interface
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Set 7 lines to the cursor - when moving vertically using j/k
    1              0.000007 set so=7
                            
                            " Avoid garbled characters in Chinese language windows OS
    1              0.000014 let $LANG='en' 
    1              0.000004 set langmenu=en
    1              0.000061 source $VIMRUNTIME/delmenu.vim
    1              0.000075 source $VIMRUNTIME/menu.vim
                            
                            " Turn on the WiLd menu
    1              0.000004 set wildmenu
                            
                            " Ignore compiled files
    1              0.000003 set wildignore=*.o,*~,*.pyc
    1              0.000008 if has("win16") || has("win32")
                                set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/.DS_Store
                            else
    1              0.000003     set wildignore+=.git\*,.hg\*,.svn\*
    1              0.000001 endif
                            
                            "Always show current position
    1              0.000002 set ruler
                            
                            " Height of the command bar
    1              0.000004 set cmdheight=2
                            
                            " A buffer becomes hidden when it is abandoned
    1              0.000003 set hid
                            
                            " Configure backspace so it acts as it should act
    1              0.000005 set backspace=eol,start,indent
    1              0.000002 set whichwrap+=<,>,h,l
                            
                            " In many terminal emulators the mouse works just fine, thus enable it.
    1              0.000003 if has('mouse')
    1              0.000002   set mouse=a
    1              0.000001 endif
                            
                            " Ignore case when searching
    1              0.000002 set ignorecase
                            
                            " When searching try to be smart about cases 
    1              0.000002 set smartcase
                            
                            " Highlight search results
    1              0.000001 set hlsearch
                            
                            " Makes search act like search in modern browsers
    1              0.000001 set incsearch 
                            
                            " Don't redraw while executing macros (good performance config)
    1              0.000002 set lazyredraw 
                            
                            " For regular expressions turn magic on
    1              0.000001 set magic
                            
                            " Show matching brackets when text indicator is over them
    1              0.000002 set showmatch 
                            " How many tenths of a second to blink when matching brackets
    1              0.000002 set mat=2
                            
                            " No annoying sound on errors
    1              0.000001 set noerrorbells
    1              0.000002 set novisualbell
    1              0.000002 set t_vb=
    1              0.000002 set tm=500
                            
                            " Add a bit extra margin to the left
    1              0.000002 set foldcolumn=1
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Colors and Fonts
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Enable syntax highlighting
    1              0.000076 syntax enable 
                            
    1              0.000003 try
    1              0.000094     colorscheme desert
    1              0.000002 catch
                            endtry
                            
    1              0.000060 set background=dark
                            
                            " Set extra options when running in GUI mode
    1              0.000006 if has("gui_running")
    1              0.000009     set guioptions-=T
    1              0.000002     set guioptions-=e
    1              0.000003     set t_Co=256
    1              0.000002     set guitablabel=%M\ %t
    1              0.000001 endif
                            
                            " Set utf8 as standard encoding and en_US as the standard language
    1              0.000085 set encoding=utf8
                            
                            " Use Unix as the standard file type
    1              0.000004 set ffs=unix,dos,mac
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Files, backups and undo
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Turn backup off, since most stuff is in SVN, git et.c anyway...
    1              0.000002 set nobackup
    1              0.000002 set nowb
    1              0.000002 set noswapfile
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Text, tab and indent related
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Use spaces instead of tabs
    1              0.000016 set expandtab
                            
                            " Be smart when using tabs ;)
    1              0.000002 set smarttab
                            
                            " 1 tab == 4 spaces
    1              0.000004 set shiftwidth=4
    1              0.000002 set tabstop=4
                            
                            " Linebreak on 500 characters
    1              0.000003 set lbr
    1              0.000003 set tw=500
                            
    1              0.000004 set ai "Auto indent
    1              0.000003 set si "Smart indent
    1              0.000001 set wrap "Wrap lines
                            
                            
                            """"""""""""""""""""""""""""""
                            " => Visual mode related
                            """"""""""""""""""""""""""""""
                            " Visual mode pressing * or # searches for the current selection
                            " Super useful! From an idea by Michael Naumann
    1              0.000011 vnoremap <silent> * :call VisualSelection('f', '')<CR>
    1              0.000006 vnoremap <silent> # :call VisualSelection('b', '')<CR>
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Moving around, tabs, windows and buffers
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Treat long lines as break lines (useful when moving around in them)
    1              0.000003 map j gj
    1              0.000003 map k gk
                            
                            " Map <Space> to / (search) and Ctrl-<Space> to ? (backwards search)
    1              0.000004 map <space> /
    1              0.000004 map <c-space> ?
                            
                            " Disable highlight when <leader><cr> is pressed
    1              0.000007 map <silent> <leader><cr> :noh<cr>
                            
                            " Smart way to move between windows
    1              0.000004 map <C-j> <C-W>j
    1              0.000003 map <C-k> <C-W>k
    1              0.000003 map <C-h> <C-W>h
    1              0.000003 map <C-l> <C-W>l
                            
                            " Close the current buffer
    1              0.000006 map <leader>bd :Bclose<cr>
                            
                            " Close all the buffers
    1              0.000006 map <leader>ba :1,1000 bd!<cr>
                            
                            " Useful mappings for managing tabs
    1              0.000005 map <leader>tn :tabnew<cr>
    1              0.000006 map <leader>to :tabonly<cr>
    1              0.000005 map <leader>tc :tabclose<cr>
    1              0.000005 map <leader>tm :tabmove 
    1              0.000007 map <leader>t<leader> :tabnext 
                            
                            " Let 'tl' toggle between this and the last accessed tab
    1              0.000004 let g:lasttab = 1
    1              0.000006 nmap <Leader>tl :exe "tabn ".g:lasttab<CR>
    1              0.000012 au TabLeave * let g:lasttab = tabpagenr()
                            
                            
                            " Opens a new tab with the current buffer's path
                            " Super useful when editing files in the same directory
    1              0.000007 map <leader>te :tabedit <c-r>=expand("%:p:h")<cr>/
                            
                            " Switch CWD to the directory of the open buffer
    1              0.000006 map <leader>cd :cd %:p:h<cr>:pwd<cr>
                            
                            " Specify the behavior when switching between buffers 
    1              0.000001 try
    1              0.000005   set switchbuf=useopen,usetab,newtab
    1              0.000021   set stal=2
    1              0.000002 catch
                            endtry
                            
                            " Return to last edit position when opening files (You want this!)
    1              0.000097 autocmd BufReadPost *
                                 \ if line("'\"") > 0 && line("'\"") <= line("$") |
                                 \   exe "normal! g`\"" |
                                 \ endif
                            " Remember info about open buffers on close
    1              0.000005 set viminfo^=%
                            
                            
                            """"""""""""""""""""""""""""""
                            " => Status line
                            """"""""""""""""""""""""""""""
                            " Always show the status line
    1              0.000004 set laststatus=2
                            
                            " Format the status line
    1              0.000006 set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{getcwd()}%h\ \ \ Line:\ %l
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Editing mappings
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Remap VIM 0 to first non-blank character
    1              0.000004 map 0 ^
                            
                            " Move a line of text using ALT+[jk] or Comamnd+[jk] on mac
    1              0.000005 nmap <M-j> mz:m+<cr>`z
    1              0.000005 nmap <M-k> mz:m-2<cr>`z
    1              0.000005 vmap <M-j> :m'>+<cr>`<my`>mzgv`yo`z
    1              0.000005 vmap <M-k> :m'<-2<cr>`>my`<mzgv`yo`z
                            
    1              0.000006 if has("mac") || has("macunix")
    1              0.000004   nmap <D-j> <M-j>
    1              0.000004   nmap <D-k> <M-k>
    1              0.000004   vmap <D-j> <M-j>
    1              0.000007   vmap <D-k> <M-k>
    1              0.000001 endif
                            
                            " Delete trailing white space on save, useful for Python and CoffeeScript ;)
    1              0.000004 func! DeleteTrailingWS()
                              exe "normal mz"
                              %s/\s\+$//ge
                              exe "normal `z"
                            endfunc
    1              0.000007 autocmd BufWrite *.py :call DeleteTrailingWS()
    1              0.000005 autocmd BufWrite *.coffee :call DeleteTrailingWS()
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Ack searching and cope displaying
                            "    requires ack.vim - it's much better than vimgrep/grep
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " When you press gv you Ack after the selected text
    1              0.000006 vnoremap <silent> gv :call VisualSelection('gv', '')<CR>
                            
                            " Open Ack and put the cursor in the right position
    1              0.000006 map <leader>g :Ack 
                            
                            " When you press <leader>r you can search and replace the selected text
    1              0.000008 vnoremap <silent> <leader>r :call VisualSelection('replace', '')<CR>
                            
                            " Do :help cope if you are unsure what cope is. It's super useful!
                            "
                            " When you search with Ack, display your results in cope by doing:
                            "   <leader>cc
                            "
                            " To go to the next search result do:
                            "   <leader>n
                            "
                            " To go to the previous search results do:
                            "   <leader>p
                            "
    1              0.000008 map <leader>cc :botright cope<cr>
    1              0.000008 map <leader>co ggVGy:tabnew<cr>:set syntax=qf<cr>pgg
    1              0.000005 map <leader>n :cn<cr>
    1              0.000006 map <leader>p :cp<cr>
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Spell checking
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Pressing ,ss will toggle and untoggle spell checking
    1              0.000006 map <leader>ss :setlocal spell!<cr>
                            
                            " Shortcuts using <leader>
    1              0.000005 map <leader>sn ]s
    1              0.000005 map <leader>sp [s
    1              0.000005 map <leader>sa zg
    1              0.000005 map <leader>s? z=
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Misc
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Remove the Windows ^M - when the encodings gets messed up
    1              0.000007 noremap <Leader>m mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm
                            
                            " Quickly open a buffer for scribble
    1              0.000006 map <leader>q :e ~/buffer<cr>
                            
                            " Quickly open a markdown buffer for scribble
    1              0.000006 map <leader>x :e ~/buffer.md<cr>
                            
                            " Toggle paste mode on and off
    1              0.000007 map <leader>pp :setlocal paste!<cr>
                            
                            
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Helper functions
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000002 function! CmdLine(str)
                                exe "menu Foo.Bar :" . a:str
                                emenu Foo.Bar
                                unmenu Foo
                            endfunction 
                            
    1              0.000002 function! VisualSelection(direction, extra_filter) range
                                let l:saved_reg = @"
                                execute "normal! vgvy"
                            
                                let l:pattern = escape(@", '\\/.*$^~[]')
                                let l:pattern = substitute(l:pattern, "\n$", "", "")
                            
                                if a:direction == 'b'
                                    execute "normal ?" . l:pattern . "^M"
                                elseif a:direction == 'gv'
                                    call CmdLine("Ack \"" . l:pattern . "\" " )
                                elseif a:direction == 'replace'
                                    call CmdLine("%s" . '/'. l:pattern . '/')
                                elseif a:direction == 'f'
                                    execute "normal /" . l:pattern . "^M"
                                endif
                            
                                let @/ = l:pattern
                                let @" = l:saved_reg
                            endfunction
                            
                            
                            " Returns true if paste mode is enabled
    1              0.000002 function! HasPaste()
                                if &paste
                                    return 'PASTE MODE  '
                                endif
                                return ''
                            endfunction
                            
                            " Don't close window, when deleting a buffer
    1              0.000007 command! Bclose call <SID>BufcloseCloseIt()
    1              0.000003 function! <SID>BufcloseCloseIt()
                               let l:currentBufNum = bufnr("%")
                               let l:alternateBufNum = bufnr("#")
                            
                               if buflisted(l:alternateBufNum)
                                 buffer #
                               else
                                 bnext
                               endif
                            
                               if bufnr("%") == l:currentBufNum
                                 new
                               endif
                            
                               if buflisted(l:currentBufNum)
                                 execute("bdelete! ".l:currentBufNum)
                               endif
                            endfunction

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/filetype.vim
Sourced 4 times
Total time:   0.126393
 Self time:   0.091861

count  total (s)   self (s)
                            " Vim support file to detect file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2015 Apr 06
                            
                            " Listen very carefully, I will say this only once
    4              0.000081 if exists("did_load_filetypes")
    1              0.000002   finish
                            endif
    3              0.000025 let did_load_filetypes = 1
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    3              0.000036 let s:cpo_save = &cpo
    3              0.000034 set cpo&vim
                            
    3              0.000013 augroup filetypedetect
                            
                            " Ignored extensions
    3              0.000018 if exists("*fnameescape")
    3              0.000285 au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew
                            	\ exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
    3              0.000057 au BufNewFile,BufRead *~
                            	\ let s:name = expand("<afile>") |
                            	\ let s:short = substitute(s:name, '\~$', '', '') |
                            	\ if s:name != s:short && s:short != "" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(s:short) |
                            	\ endif |
                            	\ unlet! s:name s:short
    3              0.000043 au BufNewFile,BufRead ?\+.in
                            	\ if expand("<afile>:t") != "configure.in" |
                            	\   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) |
                            	\ endif
    3              0.000009 elseif &verbose > 0
                              echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
                            endif
                            
                            " Pattern used to match file names which should not be inspected.
                            " Currently finds compressed files.
    3              0.000020 if !exists("g:ft_ignore_pat")
    1              0.000005   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
    1              0.000002 endif
                            
                            " Function used for patterns that end in a star: don't set the filetype if the
                            " file name matches ft_ignore_pat.
    3              0.000027 func! s:StarSetf(ft)
                              if expand("<amatch>") !~ g:ft_ignore_pat
                                exe 'setf ' . a:ft
                              endif
                            endfunc
                            
                            " Abaqus or Trasys
    3              0.000032 au BufNewFile,BufRead *.inp			call s:Check_inp()
                            
    3              0.000011 func! s:Check_inp()
                              if getline(1) =~ '^\*'
                                setf abaqus
                              else
                                let n = 1
                                if line("$") > 500
                                  let nmax = 500
                                else
                                  let nmax = line("$")
                                endif
                                while n <= nmax
                                  if getline(n) =~? "^header surface data"
                            	setf trasys
                            	break
                                  endif
                                  let n = n + 1
                                endwhile
                              endif
                            endfunc
                            
                            " A-A-P recipe
    3              0.000056 au BufNewFile,BufRead *.aap			setf aap
                            
                            " A2ps printing utility
    3              0.000188 au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
                            
                            " ABAB/4
    3              0.000031 au BufNewFile,BufRead *.abap			setf abap
                            
                            " ABC music notation
    3              0.000029 au BufNewFile,BufRead *.abc			setf abc
                            
                            " ABEL
    3              0.000036 au BufNewFile,BufRead *.abl			setf abel
                            
                            " AceDB
    3              0.000025 au BufNewFile,BufRead *.wrm			setf acedb
                            
                            " Ada (83, 9X, 95)
    3              0.000058 au BufNewFile,BufRead *.adb,*.ads,*.ada		setf ada
    3              0.000033 if has("vms")
                              au BufNewFile,BufRead *.gpr,*.ada_m,*.adc	setf ada
                            else
    3              0.000032   au BufNewFile,BufRead *.gpr			setf ada
    3              0.000006 endif
                            
                            " AHDL
    3              0.000027 au BufNewFile,BufRead *.tdf			setf ahdl
                            
                            " AMPL
    3              0.000026 au BufNewFile,BufRead *.run			setf ampl
                            
                            " Ant
    3              0.000036 au BufNewFile,BufRead build.xml			setf ant
                            
                            " Arduino
    3              0.000050 au BufNewFile,BufRead *.ino,*.pde		setf arduino
                            
                            " Apache style config file
    3              0.000038 au BufNewFile,BufRead proftpd.conf*		call s:StarSetf('apachestyle')
                            
                            " Apache config file
    3              0.000070 au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf		setf apache
                            
                            " XA65 MOS6510 cross assembler
    3              0.000029 au BufNewFile,BufRead *.a65			setf a65
                            
                            " Applescript
    3              0.000029 au BufNewFile,BufRead *.scpt			setf applescript
                            
                            " Applix ELF
    3              0.000039 au BufNewFile,BufRead *.am
                            	\ if expand("<afile>") !~? 'Makefile.am\>' | setf elf | endif
                            
                            " ALSA configuration
    3              0.000103 au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
                            
                            " Arc Macro Language
    3              0.000031 au BufNewFile,BufRead *.aml			setf aml
                            
                            " APT config file
    3              0.000033 au BufNewFile,BufRead apt.conf		       setf aptconf
    3              0.000044 au BufNewFile,BufRead */.aptitude/config       setf aptconf
    3              0.000091 au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} setf aptconf
                            
                            " Arch Inventory file
    3              0.000070 au BufNewFile,BufRead .arch-inventory,=tagging-method	setf arch
                            
                            " ART*Enterprise (formerly ART-IM)
    3              0.000029 au BufNewFile,BufRead *.art			setf art
                            
                            " AsciiDoc
    3              0.000035 au BufNewFile,BufRead *.asciidoc		setf asciidoc
                            
                            " ASN.1
    3              0.000053 au BufNewFile,BufRead *.asn,*.asn1		setf asn
                            
                            " Active Server Pages (with Visual Basic Script)
    3              0.000043 au BufNewFile,BufRead *.asa
                            	\ if exists("g:filetype_asa") |
                            	\   exe "setf " . g:filetype_asa |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Active Server Pages (with Perl or Visual Basic Script)
    3              0.000078 au BufNewFile,BufRead *.asp
                            	\ if exists("g:filetype_asp") |
                            	\   exe "setf " . g:filetype_asp |
                            	\ elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |
                            	\   setf aspperl |
                            	\ else |
                            	\   setf aspvbs |
                            	\ endif
                            
                            " Grub (must be before catch *.lst)
    3              0.000117 au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
                            
                            " Assembly (all kinds)
                            " *.lst is not pure assembly, it has two extra columns (address, byte codes)
    3              0.000118 au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst	call s:FTasm()
                            
                            " This function checks for the kind of assembly that is wanted by the user, or
                            " can be detected from the first five lines of the file.
    3              0.000036 func! s:FTasm()
                              " make sure b:asmsyntax exists
                              if !exists("b:asmsyntax")
                                let b:asmsyntax = ""
                              endif
                            
                              if b:asmsyntax == ""
                                call s:FTasmsyntax()
                              endif
                            
                              " if b:asmsyntax still isn't set, default to asmsyntax or GNU
                              if b:asmsyntax == ""
                                if exists("g:asmsyntax")
                                  let b:asmsyntax = g:asmsyntax
                                else
                                  let b:asmsyntax = "asm"
                                endif
                              endif
                            
                              exe "setf " . fnameescape(b:asmsyntax)
                            endfunc
                            
    3              0.000018 func! s:FTasmsyntax()
                              " see if file contains any asmsyntax=foo overrides. If so, change
                              " b:asmsyntax appropriately
                              let head = " ".getline(1)." ".getline(2)." ".getline(3)." ".getline(4).
                            	\" ".getline(5)." "
                              let match = matchstr(head, '\sasmsyntax=\zs[a-zA-Z0-9]\+\ze\s')
                              if match != ''
                                let b:asmsyntax = match
                              elseif ((head =~? '\.title') || (head =~? '\.ident') || (head =~? '\.macro') || (head =~? '\.subtitle') || (head =~? '\.library'))
                                let b:asmsyntax = "vmasm"
                              endif
                            endfunc
                            
                            " Macro (VAX)
    3              0.000072 au BufNewFile,BufRead *.mar			setf vmasm
                            
                            " Atlas
    3              0.000095 au BufNewFile,BufRead *.atl,*.as		setf atlas
                            
                            " Autoit v3
    3              0.000044 au BufNewFile,BufRead *.au3			setf autoit
                            
                            " Autohotkey
    3              0.000041 au BufNewFile,BufRead *.ahk			setf autohotkey
                            
                            " Automake
    3              0.000078 au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am	setf automake
                            
                            " Autotest .at files are actually m4
    3              0.000031 au BufNewFile,BufRead *.at			setf m4
                            
                            " Avenue
    3              0.000032 au BufNewFile,BufRead *.ave			setf ave
                            
                            " Awk
    3              0.000029 au BufNewFile,BufRead *.awk			setf awk
                            
                            " B
    3              0.000221 au BufNewFile,BufRead *.mch,*.ref,*.imp		setf b
                            
                            " BASIC or Visual Basic
    3              0.000051 au BufNewFile,BufRead *.bas			call s:FTVB("basic")
                            
                            " Check if one of the first five lines contains "VB_Name".  In that case it is
                            " probably a Visual Basic file.  Otherwise it's assumed to be "alt" filetype.
    3              0.000023 func! s:FTVB(alt)
                              if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'VB_Name\|Begin VB\.\(Form\|MDIForm\|UserControl\)'
                                setf vb
                              else
                                exe "setf " . a:alt
                              endif
                            endfunc
                            
                            " Visual Basic Script (close to Visual Basic) or Visual Basic .NET
    3              0.001273 au BufNewFile,BufRead *.vb,*.vbs,*.dsm,*.ctl	setf vb
                            
                            " IBasic file (similar to QBasic)
    3              0.000210 au BufNewFile,BufRead *.iba,*.ibi		setf ibasic
                            
                            " FreeBasic file (similar to QBasic)
    3              0.000064 au BufNewFile,BufRead *.fb,*.bi			setf freebasic
                            
                            " Batch file for MSDOS.
    3              0.000058 au BufNewFile,BufRead *.bat,*.sys		setf dosbatch
                            " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
    3              0.000036 au BufNewFile,BufRead *.cmd
                            	\ if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
                            
                            " Batch file for 4DOS
    3              0.000036 au BufNewFile,BufRead *.btm			call s:FTbtm()
    3              0.000018 func! s:FTbtm()
                              if exists("g:dosbatch_syntax_for_btm") && g:dosbatch_syntax_for_btm
                                setf dosbatch
                              else
                                setf btm
                              endif
                            endfunc
                            
                            " BC calculator
    3              0.000199 au BufNewFile,BufRead *.bc			setf bc
                            
                            " BDF font
    3              0.000072 au BufNewFile,BufRead *.bdf			setf bdf
                            
                            " BibTeX bibliography database file
    3              0.000042 au BufNewFile,BufRead *.bib			setf bib
                            
                            " BibTeX Bibliography Style
    3              0.000037 au BufNewFile,BufRead *.bst			setf bst
                            
                            " BIND configuration
    3              0.000102 au BufNewFile,BufRead named.conf,rndc.conf	setf named
                            
                            " BIND zone
    3              0.000043 au BufNewFile,BufRead named.root		setf bindzone
    3              0.000037 au BufNewFile,BufRead *.db			call s:BindzoneCheck('')
                            
    3              0.000016 func! s:BindzoneCheck(default)
                              if getline(1).getline(2).getline(3).getline(4) =~ '^; <<>> DiG [0-9.]\+ <<>>\|BIND.*named\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                setf bindzone
                              elseif a:default != ''
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            " Blank
    3              0.000036 au BufNewFile,BufRead *.bl			setf blank
                            
                            " Blkid cache file
    3              0.000715 au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
                            
                            " C or lpc
    3              0.000057 au BufNewFile,BufRead *.c			call s:FTlpc()
                            
    3              0.000013 func! s:FTlpc()
                              if exists("g:lpc_syntax_for_c")
                                let lnum = 1
                                while lnum <= 12
                                  if getline(lnum) =~# '^\(//\|inherit\|private\|protected\|nosave\|string\|object\|mapping\|mixed\)'
                            	setf lpc
                            	return
                                  endif
                                  let lnum = lnum + 1
                                endwhile
                              endif
                              setf c
                            endfunc
                            
                            " Calendar
    3              0.000045 au BufNewFile,BufRead calendar			setf calendar
                            
                            " C#
    3              0.000041 au BufNewFile,BufRead *.cs			setf cs
                            
                            " CSDL
    3              0.000034 au BufNewFile,BufRead *.csdl			setf csdl
                            
                            " Cabal
    3              0.000033 au BufNewFile,BufRead *.cabal			setf cabal
                            
                            " Cdrdao TOC
    3              0.000036 au BufNewFile,BufRead *.toc			setf cdrtoc
                            
                            " Cdrdao config
    3              0.000159 au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao	setf cdrdaoconf
                            
                            " Cfengine
    3              0.000045 au BufNewFile,BufRead cfengine.conf		setf cfengine
                            
                            " ChaiScript
    3              0.000035 au BufRead,BufNewFile *.chai			setf chaiscript
                            
                            " Comshare Dimension Definition Language
    3              0.000032 au BufNewFile,BufRead *.cdl			setf cdl
                            
                            " Conary Recipe
    3              0.000034 au BufNewFile,BufRead *.recipe			setf conaryrecipe
                            
                            " Controllable Regex Mutilator
    3              0.000034 au BufNewFile,BufRead *.crm			setf crm
                            
                            " Cyn++
    3              0.000033 au BufNewFile,BufRead *.cyn			setf cynpp
                            
                            " Cynlib
                            " .cc and .cpp files can be C++ or Cynlib.
    3              0.000037 au BufNewFile,BufRead *.cc
                            	\ if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
    3              0.000038 au BufNewFile,BufRead *.cpp
                            	\ if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
                            
                            " C++
    3              0.000210 au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
    3              0.000030 if has("fname_case")
                              au BufNewFile,BufRead *.C,*.H setf cpp
                            endif
                            
                            " .h files can be C, Ch C++, ObjC or ObjC++.
                            " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
                            " detected automatically.
    3              0.000035 au BufNewFile,BufRead *.h			call s:FTheader()
                            
    3              0.000013 func! s:FTheader()
                              if match(getline(1, min([line("$"), 200])), '^@\(interface\|end\|class\)') > -1
                                if exists("g:c_syntax_for_h")
                                  setf objc
                                else
                                  setf objcpp
                                endif
                              elseif exists("g:c_syntax_for_h")
                                setf c
                              elseif exists("g:ch_syntax_for_h")
                                setf ch
                              else
                                setf cpp
                              endif
                            endfunc
                            
                            " Ch (CHscript)
    3              0.000037 au BufNewFile,BufRead *.chf			setf ch
                            
                            " TLH files are C++ headers generated by Visual C++'s #import from typelibs
    3              0.000037 au BufNewFile,BufRead *.tlh			setf cpp
                            
                            " Cascading Style Sheets
    3              0.000034 au BufNewFile,BufRead *.css			setf css
                            
                            " Century Term Command Scripts (*.cmd too)
    3              0.000030 au BufNewFile,BufRead *.con			setf cterm
                            
                            " Changelog
    3              0.000138 au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch
                            					\	setf debchangelog
                            
    3              0.000062 au BufNewFile,BufRead [cC]hange[lL]og
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| else
                            	\|   setf changelog
                            	\| endif
                            
    3              0.000047 au BufNewFile,BufRead NEWS
                            	\  if getline(1) =~ '; urgency='
                            	\|   setf debchangelog
                            	\| endif
                            
                            " CHILL
    3              0.000036 au BufNewFile,BufRead *..ch			setf chill
                            
                            " Changes for WEB and CWEB or CHILL
    3              0.000035 au BufNewFile,BufRead *.ch			call s:FTchange()
                            
                            " This function checks if one of the first ten lines start with a '@'.  In
                            " that case it is probably a change file.
                            " If the first line starts with # or ! it's probably a ch file.
                            " If a line has "main", "include", "//" ir "/*" it's probably ch.
                            " Otherwise CHILL is assumed.
    3              0.000010 func! s:FTchange()
                              let lnum = 1
                              while lnum <= 10
                                if getline(lnum)[0] == '@'
                                  setf change
                                  return
                                endif
                                if lnum == 1 && (getline(1)[0] == '#' || getline(1)[0] == '!')
                                  setf ch
                                  return
                                endif
                                if getline(lnum) =~ "MODULE"
                                  setf chill
                                  return
                                endif
                                if getline(lnum) =~ 'main\s*(\|#\s*include\|//'
                                  setf ch
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                              setf chill
                            endfunc
                            
                            " ChordPro
    3              0.000144 au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro	setf chordpro
                            
                            " Clean
    3              0.000064 au BufNewFile,BufRead *.dcl,*.icl		setf clean
                            
                            " Clever
    3              0.000037 au BufNewFile,BufRead *.eni			setf cl
                            
                            " Clever or dtd
    3              0.000032 au BufNewFile,BufRead *.ent			call s:FTent()
                            
    3              0.000007 func! s:FTent()
                              " This function checks for valid cl syntax in the first five lines.
                              " Look for either an opening comment, '#', or a block start, '{".
                              " If not found, assume SGML.
                              let lnum = 1
                              while lnum < 6
                                let line = getline(lnum)
                                if line =~ '^\s*[#{]'
                                  setf cl
                                  return
                                elseif line !~ '^\s*$'
                                  " Not a blank line, not a comment, and not a block start,
                                  " so doesn't look like valid cl code.
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf dtd
                            endfunc
                            
                            " Clipper (or FoxPro; could also be eviews)
    3              0.000060 au BufNewFile,BufRead *.prg
                            	\ if exists("g:filetype_prg") |
                            	\   exe "setf " . g:filetype_prg |
                            	\ else |
                            	\   setf clipper |
                            	\ endif
                            
                            " Clojure
    3              0.000063 au BufNewFile,BufRead *.clj,*.cljs		setf clojure
                            
                            " Cmake
    3              0.000102 au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in		setf cmake
                            
                            " Cmusrc
    3              0.000080 au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
    3              0.000050 au BufNewFile,BufRead */cmus/{rc,*.theme}			setf cmusrc
                            
                            " Cobol
    3              0.000087 au BufNewFile,BufRead *.cbl,*.cob,*.lib	setf cobol
                            "   cobol or zope form controller python script? (heuristic)
    3              0.000050 au BufNewFile,BufRead *.cpy
                            	\ if getline(1) =~ '^##' |
                            	\   setf python |
                            	\ else |
                            	\   setf cobol |
                            	\ endif
                            
                            " Coco/R
    3              0.000040 au BufNewFile,BufRead *.atg			setf coco
                            
                            " Cold Fusion
    3              0.000085 au BufNewFile,BufRead *.cfm,*.cfi,*.cfc		setf cf
                            
                            " Configure scripts
    3              0.000135 au BufNewFile,BufRead configure.in,configure.ac setf config
                            
                            " CUDA  Cumpute Unified Device Architecture
    3              0.000044 au BufNewFile,BufRead *.cu			setf cuda
                            
                            " Dockerfile
    3              0.000048 au BufNewFile,BufRead Dockerfile		setf dockerfile
                            
                            " WildPackets EtherPeek Decoder
    3              0.000040 au BufNewFile,BufRead *.dcd			setf dcd
                            
                            " Enlightenment configuration files
    3              0.000055 au BufNewFile,BufRead *enlightenment/*.cfg	setf c
                            
                            " Eterm
    3              0.000050 au BufNewFile,BufRead *Eterm/*.cfg		setf eterm
                            
                            " Euphoria 3 or 4
    3              0.000141 au BufNewFile,BufRead *.eu,*.ew,*.ex,*.exu,*.exw  call s:EuphoriaCheck()
    3              0.000025 if has("fname_case")
                               au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call s:EuphoriaCheck()
                            endif
                            
    3              0.000015 func! s:EuphoriaCheck()
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              else
                                setf euphoria3
                              endif
                            endfunc
                            
                            " Lynx config files
    3              0.000053 au BufNewFile,BufRead lynx.cfg			setf lynx
                            
                            " Quake
    3              0.000091 au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg	setf quake
    3              0.000051 au BufNewFile,BufRead *quake[1-3]/*.cfg			setf quake
                            
                            " Quake C
    3              0.000038 au BufNewFile,BufRead *.qc			setf c
                            
                            " Configure files
    3              0.000044 au BufNewFile,BufRead *.cfg			setf cfg
                            
                            " Cucumber
    3              0.000043 au BufNewFile,BufRead *.feature			setf cucumber
                            
                            " Communicating Sequential Processes
    3              0.000065 au BufNewFile,BufRead *.csp,*.fdr		setf csp
                            
                            " CUPL logic description and simulation
    3              0.000039 au BufNewFile,BufRead *.pld			setf cupl
    3              0.000040 au BufNewFile,BufRead *.si			setf cuplsim
                            
                            " Debian Control
    3              0.000046 au BufNewFile,BufRead */debian/control		setf debcontrol
    3              0.000056 au BufNewFile,BufRead control
                            	\  if getline(1) =~ '^Source:'
                            	\|   setf debcontrol
                            	\| endif
                            
                            " Debian Sources.list
    3              0.000053 au BufNewFile,BufRead */etc/apt/sources.list		setf debsources
    3              0.000060 au BufNewFile,BufRead */etc/apt/sources.list.d/*.list	setf debsources
                            
                            " Deny hosts
    3              0.000052 au BufNewFile,BufRead denyhosts.conf		setf denyhosts
                            
                            " dnsmasq(8) configuration files
    3              0.000052 au BufNewFile,BufRead */etc/dnsmasq.conf	setf dnsmasq
                            
                            " ROCKLinux package description
    3              0.000042 au BufNewFile,BufRead *.desc			setf desc
                            
                            " the D language or dtrace
    3              0.000039 au BufNewFile,BufRead *.d			call s:DtraceCheck()
                            
    3              0.000010 func! s:DtraceCheck()
                              let lines = getline(1, min([line("$"), 100]))
                              if match(lines, '^module\>\|^import\>') > -1
                                " D files often start with a module and/or import statement.
                                setf d
                              elseif match(lines, '^#!\S\+dtrace\|#pragma\s\+D\s\+option\|:\S\{-}:\S\{-}:') > -1
                                setf dtrace
                              else
                                setf d
                              endif
                            endfunc
                            
                            " Desktop files
    3              0.000084 au BufNewFile,BufRead *.desktop,.directory	setf desktop
                            
                            " Dict config
    3              0.000079 au BufNewFile,BufRead dict.conf,.dictrc		setf dictconf
                            
                            " Dictd config
    3              0.000060 au BufNewFile,BufRead dictd.conf		setf dictdconf
                            
                            " Diff files
    3              0.000100 au BufNewFile,BufRead *.diff,*.rej,*.patch	setf diff
                            
                            " Dircolors
    3              0.000111 au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS	setf dircolors
                            
                            " Diva (with Skill) or InstallShield
    3              0.000054 au BufNewFile,BufRead *.rul
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |
                            	\   setf ishd |
                            	\ else |
                            	\   setf diva |
                            	\ endif
                            
                            " DCL (Digital Command Language - vms) or DNS zone file
    3              0.000044 au BufNewFile,BufRead *.com			call s:BindzoneCheck('dcl')
                            
                            " DOT
    3              0.000036 au BufNewFile,BufRead *.dot			setf dot
                            
                            " Dylan - lid files
    3              0.000050 au BufNewFile,BufRead *.lid			setf dylanlid
                            
                            " Dylan - intr files (melange)
    3              0.000048 au BufNewFile,BufRead *.intr			setf dylanintr
                            
                            " Dylan
    3              0.000040 au BufNewFile,BufRead *.dylan			setf dylan
                            
                            " Microsoft Module Definition
    3              0.000039 au BufNewFile,BufRead *.def			setf def
                            
                            " Dracula
    3              0.000127 au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe	setf dracula
                            
                            " Datascript
    3              0.000041 au BufNewFile,BufRead *.ds			setf datascript
                            
                            " dsl
    3              0.000041 au BufNewFile,BufRead *.dsl			setf dsl
                            
                            " DTD (Document Type Definition for XML)
    3              0.000036 au BufNewFile,BufRead *.dtd			setf dtd
                            
                            " DTS/DSTI (device tree files)
    3              0.000069 au BufNewFile,BufRead *.dts,*.dtsi		setf dts
                            
                            " EDIF (*.edf,*.edif,*.edn,*.edo)
    3              0.000049 au BufNewFile,BufRead *.ed\(f\|if\|n\|o\)	setf edif
                            
                            " Embedix Component Description
    3              0.000043 au BufNewFile,BufRead *.ecd			setf ecd
                            
                            " Eiffel or Specman or Euphoria
    3              0.000062 au BufNewFile,BufRead *.e,*.E			call s:FTe()
                            
                            " Elinks configuration
    3              0.000094 au BufNewFile,BufRead */etc/elinks.conf,*/.elinks/elinks.conf	setf elinks
                            
    3              0.000010 func! s:FTe()
                              if exists('g:filetype_euphoria')
                                exe 'setf ' . g:filetype_euphoria
                              else
                                let n = 1
                                while n < 100 && n < line("$")
                                  if getline(n) =~ "^\\s*\\(<'\\|'>\\)\\s*$"
                                    setf specman
                                    return
                                  endif
                                  let n = n + 1
                                endwhile
                                setf eiffel
                              endif
                            endfunc
                            
                            " ERicsson LANGuage; Yaws is erlang too
    3              0.000106 au BufNewFile,BufRead *.erl,*.hrl,*.yaws	setf erlang
                            
                            " Elm Filter Rules file
    3              0.000051 au BufNewFile,BufRead filter-rules		setf elmfilt
                            
                            " ESMTP rc file
    3              0.000042 au BufNewFile,BufRead *esmtprc			setf esmtprc
                            
                            " ESQL-C
    3              0.000084 au BufNewFile,BufRead *.ec,*.EC			setf esqlc
                            
                            " Esterel
    3              0.000040 au BufNewFile,BufRead *.strl			setf esterel
                            
                            " Essbase script
    3              0.000040 au BufNewFile,BufRead *.csc			setf csc
                            
                            " Exim
    3              0.000043 au BufNewFile,BufRead exim.conf			setf exim
                            
                            " Expect
    3              0.000044 au BufNewFile,BufRead *.exp			setf expect
                            
                            " Exports
    3              0.000039 au BufNewFile,BufRead exports			setf exports
                            
                            " Falcon
    3              0.000038 au BufNewFile,BufRead *.fal			setf falcon
                            
                            " Fantom
    3              0.000068 au BufNewFile,BufRead *.fan,*.fwt		setf fan
                            
                            " Factor
    3              0.000039 au BufNewFile,BufRead *.factor			setf factor
                            
                            " Fetchmail RC file
    3              0.000056 au BufNewFile,BufRead .fetchmailrc		setf fetchmail
                            
                            " FlexWiki - disabled, because it has side effects when a .wiki file
                            " is not actually FlexWiki
                            "au BufNewFile,BufRead *.wiki			setf flexwiki
                            
                            " Focus Executable
    3              0.000066 au BufNewFile,BufRead *.fex,*.focexec		setf focexec
                            
                            " Focus Master file (but not for auto.master)
    3              0.000045 au BufNewFile,BufRead auto.master		setf conf
    3              0.000068 au BufNewFile,BufRead *.mas,*.master		setf master
                            
                            " Forth
    3              0.000067 au BufNewFile,BufRead *.fs,*.ft			setf forth
                            
                            " Reva Forth
    3              0.000048 au BufNewFile,BufRead *.frt			setf reva
                            
                            " Fortran
    3              0.000019 if has("fname_case")
                              au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08	 setf fortran
                            endif
    3              0.000304 au BufNewFile,BufRead   *.f,*.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08  setf fortran
                            
                            " Framescript
    3              0.000044 au BufNewFile,BufRead *.fsl			setf framescript
                            
                            " FStab
    3              0.000168 au BufNewFile,BufRead fstab,mtab		setf fstab
                            
                            " GDB command files
    3              0.000118 au BufNewFile,BufRead .gdbinit			setf gdb
                            
                            " GDMO
    3              0.000114 au BufNewFile,BufRead *.mo,*.gdmo		setf gdmo
                            
                            " Gedcom
    3              0.000086 au BufNewFile,BufRead *.ged,lltxxxxx.txt	setf gedcom
                            
                            " Git
    3              0.000055 au BufNewFile,BufRead *.git/COMMIT_EDITMSG	setf gitcommit
    3              0.000045 au BufNewFile,BufRead *.git/MERGE_MSG		setf gitcommit
    3              0.000108 au BufNewFile,BufRead *.git/config,.gitconfig,.gitmodules setf gitconfig
    3              0.000056 au BufNewFile,BufRead *.git/modules/*/COMMIT_EDITMSG setf gitcommit
    3              0.000053 au BufNewFile,BufRead *.git/modules/*/config	setf gitconfig
    3              0.000049 au BufNewFile,BufRead */.config/git/config	setf gitconfig
    3              0.000024 if !empty($XDG_CONFIG_HOME)
                              au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config	setf gitconfig
                            endif
    3              0.000050 au BufNewFile,BufRead git-rebase-todo		setf gitrebase
    3              0.000056 au BufNewFile,BufRead .msg.[0-9]*
                                  \ if getline(1) =~ '^From.*# This line is ignored.$' |
                                  \   setf gitsendemail |
                                  \ endif
    3              0.000049 au BufNewFile,BufRead *.git/*
                                  \ if getline(1) =~ '^\x\{40\}\>\|^ref: ' |
                                  \   setf git |
                                  \ endif
                            
                            " Gkrellmrc
    3              0.000084 au BufNewFile,BufRead gkrellmrc,gkrellmrc_?	setf gkrellmrc
                            
                            " GP scripts (2.0 and onward)
    3              0.000081 au BufNewFile,BufRead *.gp,.gprc		setf gp
                            
                            " GPG
    3              0.000053 au BufNewFile,BufRead */.gnupg/options		setf gpg
    3              0.000045 au BufNewFile,BufRead */.gnupg/gpg.conf		setf gpg
    3              0.000057 au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
                            
                            " gnash(1) configuration files
    3              0.000198 au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
                            
                            " Gitolite
    3              0.000064 au BufNewFile,BufRead gitolite.conf		setf gitolite
    3              0.000063 au BufNewFile,BufRead */gitolite-admin/conf/*	call s:StarSetf('gitolite')
    3              0.000173 au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc	setf perl
                            
                            " Gnuplot scripts
    3              0.000059 au BufNewFile,BufRead *.gpi			setf gnuplot
                            
                            " Go (Google)
    3              0.000046 au BufNewFile,BufRead *.go			setf go
                            
                            " GrADS scripts
    3              0.000039 au BufNewFile,BufRead *.gs			setf grads
                            
                            " Gretl
    3              0.000044 au BufNewFile,BufRead *.gretl			setf gretl
                            
                            " Groovy
    3              0.000050 au BufNewFile,BufRead *.groovy			setf groovy
                            
                            " GNU Server Pages
    3              0.000044 au BufNewFile,BufRead *.gsp			setf gsp
                            
                            " Group file
    3              0.000335 au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
                            
                            " GTK RC
    3              0.000084 au BufNewFile,BufRead .gtkrc,gtkrc		setf gtkrc
                            
                            " Haml
    3              0.000073 au BufNewFile,BufRead *.haml			setf haml
                            
                            " Hamster Classic | Playground files
    3              0.000113 au BufNewFile,BufRead *.hsc,*.hsm		setf hamster
                            
                            " Haskell
    3              0.000090 au BufNewFile,BufRead *.hs,*.hs-boot		setf haskell
    3              0.000051 au BufNewFile,BufRead *.lhs			setf lhaskell
    3              0.000044 au BufNewFile,BufRead *.chs			setf chaskell
                            
                            " Haste
    3              0.000081 au BufNewFile,BufRead *.ht			setf haste
    3              0.000047 au BufNewFile,BufRead *.htpp			setf hastepreproc
                            
                            " Hercules
    3              0.000180 au BufNewFile,BufRead *.vc,*.ev,*.rs,*.sum,*.errsum	setf hercules
                            
                            " HEX (Intel)
    3              0.000078 au BufNewFile,BufRead *.hex,*.h32		setf hex
                            
                            " Tilde (must be before HTML)
    3              0.000046 au BufNewFile,BufRead *.t.html			setf tilde
                            
                            " HTML (.shtml and .stm for server side)
    3              0.000146 au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call s:FThtml()
                            
                            " Distinguish between HTML, XHTML and Django
    3              0.000016 func! s:FThtml()
                              let n = 1
                              while n < 10 && n < line("$")
                                if getline(n) =~ '\<DTD\s\+XHTML\s'
                                  setf xhtml
                                  return
                                endif
                                if getline(n) =~ '{%\s*\(extends\|block\|load\)\>'
                                  setf htmldjango
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf html
                            endfunc
                            
                            " HTML with Ruby - eRuby
    3              0.000088 au BufNewFile,BufRead *.erb,*.rhtml		setf eruby
                            
                            " HTML with M4
    3              0.000050 au BufNewFile,BufRead *.html.m4			setf htmlm4
                            
                            " HTML Cheetah template
    3              0.000043 au BufNewFile,BufRead *.tmpl			setf htmlcheetah
                            
                            " Host config
    3              0.000053 au BufNewFile,BufRead */etc/host.conf		setf hostconf
                            
                            " Hosts access
    3              0.000092 au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
                            
                            " Hyper Builder
    3              0.000047 au BufNewFile,BufRead *.hb			setf hb
                            
                            " Httest
    3              0.000080 au BufNewFile,BufRead *.htt,*.htb		setf httest
                            
                            " Icon
    3              0.000050 au BufNewFile,BufRead *.icn			setf icon
                            
                            " IDL (Interface Description Language)
    3              0.000044 au BufNewFile,BufRead *.idl			call s:FTidl()
                            
                            " Distinguish between standard IDL and MS-IDL
    3              0.000008 func! s:FTidl()
                              let n = 1
                              while n < 50 && n < line("$")
                                if getline(n) =~ '^\s*import\s\+"\(unknwn\|objidl\)\.idl"'
                                  setf msidl
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf idl
                            endfunc
                            
                            " Microsoft IDL (Interface Description Language)  Also *.idl
                            " MOF = WMI (Windows Management Instrumentation) Managed Object Format
    3              0.000084 au BufNewFile,BufRead *.odl,*.mof		setf msidl
                            
                            " Icewm menu
    3              0.000055 au BufNewFile,BufRead */.icewm/menu		setf icemenu
                            
                            " Indent profile (must come before IDL *.pro!)
    3              0.000047 au BufNewFile,BufRead .indent.pro		setf indent
    3              0.000052 au BufNewFile,BufRead indent.pro		call s:ProtoCheck('indent')
                            
                            " IDL (Interactive Data Language)
    3              0.000047 au BufNewFile,BufRead *.pro			call s:ProtoCheck('idlang')
                            
                            " Distinguish between "default" and Cproto prototype file. */
    3              0.000011 func! s:ProtoCheck(default)
                              " Cproto files have a comment in the first line and a function prototype in
                              " the second line, it always ends in ";".  Indent files may also have
                              " comments, thus we can't match comments to see the difference.
                              " IDL files can have a single ';' in the second line, require at least one
                              " chacter before the ';'.
                              if getline(2) =~ '.;$'
                                setf cpp
                              else
                                exe 'setf ' . a:default
                              endif
                            endfunc
                            
                            
                            " Indent RC
    3              0.000056 au BufNewFile,BufRead indentrc			setf indent
                            
                            " Inform
    3              0.000085 au BufNewFile,BufRead *.inf,*.INF		setf inform
                            
                            " Initng
    3              0.000088 au BufNewFile,BufRead */etc/initng/*/*.i,*.ii	setf initng
                            
                            " Innovation Data Processing
    3              0.000144 au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c 	setf upstreamdat
    3              0.000130 au BufRead,BufNewFile upstream.log\c,upstream.*.log\c,*.upstream.log\c 	setf upstreamlog
    3              0.000133 au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
    3              0.000257 au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c 	setf usserverlog
    3              0.000384 au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c 	setf usw2kagtlog
                            
                            " Ipfilter
    3              0.000286 au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules	setf ipfilter
                            
                            " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
    3              0.000502 au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl	setf fgl
                            
                            " .INI file for MSDOS
    3              0.000110 au BufNewFile,BufRead *.ini			setf dosini
                            
                            " SysV Inittab
    3              0.000080 au BufNewFile,BufRead inittab			setf inittab
                            
                            " Inno Setup
    3              0.000071 au BufNewFile,BufRead *.iss			setf iss
                            
                            " J
    3              0.000085 au BufNewFile,BufRead *.ijs			setf j
                            
                            " JAL
    3              0.000151 au BufNewFile,BufRead *.jal,*.JAL		setf jal
                            
                            " Jam
    3              0.000091 au BufNewFile,BufRead *.jpl,*.jpr		setf jam
                            
                            " Java
    3              0.000085 au BufNewFile,BufRead *.java,*.jav		setf java
                            
                            " JavaCC
    3              0.000087 au BufNewFile,BufRead *.jj,*.jjt		setf javacc
                            
                            " JavaScript, ECMAScript
    3              0.000177 au BufNewFile,BufRead *.js,*.javascript,*.es,*.jsx   setf javascript
                            
                            " Java Server Pages
    3              0.000052 au BufNewFile,BufRead *.jsp			setf jsp
                            
                            " Java Properties resource file (note: doesn't catch font.properties.pl)
    3              0.000500 au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??	setf jproperties
    3              0.000088 au BufNewFile,BufRead *.properties_??_??_*	call s:StarSetf('jproperties')
                            
                            " Jess
    3              0.000069 au BufNewFile,BufRead *.clp			setf jess
                            
                            " Jgraph
    3              0.000048 au BufNewFile,BufRead *.jgr			setf jgraph
                            
                            " Jovial
    3              0.000146 au BufNewFile,BufRead *.jov,*.j73,*.jovial	setf jovial
                            
                            " JSON
    3              0.000088 au BufNewFile,BufRead *.json,*.jsonp		setf json
                            
                            " Kixtart
    3              0.000052 au BufNewFile,BufRead *.kix			setf kix
                            
                            " Kimwitu[++]
    3              0.000043 au BufNewFile,BufRead *.k			setf kwt
                            
                            " Kivy
    3              0.000044 au BufNewFile,BufRead *.kv			setf kivy
                            
                            " KDE script
    3              0.000042 au BufNewFile,BufRead *.ks			setf kscript
                            
                            " Kconfig
    3              0.000090 au BufNewFile,BufRead Kconfig,Kconfig.debug	setf kconfig
                            
                            " Lace (ISE)
    3              0.000091 au BufNewFile,BufRead *.ace,*.ACE		setf lace
                            
                            " Latte
    3              0.000084 au BufNewFile,BufRead *.latte,*.lte		setf latte
                            
                            " Limits
    3              0.000151 au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf	setf limits
                            
                            " LambdaProlog (*.mod too, see Modsim)
    3              0.000051 au BufNewFile,BufRead *.sig			setf lprolog
                            
                            " LDAP LDIF
    3              0.000046 au BufNewFile,BufRead *.ldif			setf ldif
                            
                            " Ld loader
    3              0.000044 au BufNewFile,BufRead *.ld			setf ld
                            
                            " Less
    3              0.000044 au BufNewFile,BufRead *.less			setf less
                            
                            " Lex
    3              0.000153 au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++	setf lex
                            
                            " Libao
    3              0.000095 au BufNewFile,BufRead */etc/libao.conf,*/.libao	setf libao
                            
                            " Libsensors
    3              0.000093 au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf	setf sensors
                            
                            " LFTP
    3              0.000126 au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc	setf lftp
                            
                            " Lifelines (or Lex for C++!)
    3              0.000049 au BufNewFile,BufRead *.ll			setf lifelines
                            
                            " Lilo: Linux loader
    3              0.000048 au BufNewFile,BufRead lilo.conf			setf lilo
                            
                            " Lisp (*.el = ELisp, *.cl = Common Lisp, *.jl = librep Lisp)
    3              0.000028 if has("fname_case")
                              au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,*.L,.emacs,.sawfishrc setf lisp
                            else
    3              0.000279   au BufNewFile,BufRead *.lsp,*.lisp,*.el,*.cl,*.jl,.emacs,.sawfishrc setf lisp
    3              0.000004 endif
                            
                            " SBCL implementation of Common Lisp
    3              0.000089 au BufNewFile,BufRead sbclrc,.sbclrc		setf lisp
                            
                            " Liquid
    3              0.000049 au BufNewFile,BufRead *.liquid			setf liquid
                            
                            " Lite
    3              0.000080 au BufNewFile,BufRead *.lite,*.lt		setf lite
                            
                            " LiteStep RC files
    3              0.000056 au BufNewFile,BufRead */LiteStep/*/*.rc		setf litestep
                            
                            " Login access
    3              0.000054 au BufNewFile,BufRead */etc/login.access	setf loginaccess
                            
                            " Login defs
    3              0.000051 au BufNewFile,BufRead */etc/login.defs		setf logindefs
                            
                            " Logtalk
    3              0.000054 au BufNewFile,BufRead *.lgt			setf logtalk
                            
                            " LOTOS
    3              0.000088 au BufNewFile,BufRead *.lot,*.lotos		setf lotos
                            
                            " Lout (also: *.lt)
    3              0.000084 au BufNewFile,BufRead *.lou,*.lout		setf lout
                            
                            " Lua
    3              0.000049 au BufNewFile,BufRead *.lua			setf lua
                            
                            " Luarocks
    3              0.000050 au BufNewFile,BufRead *.rockspec		setf lua
                            
                            " Linden Scripting Language (Second Life)
    3              0.000047 au BufNewFile,BufRead *.lsl			setf lsl
                            
                            " Lynx style file (or LotusScript!)
    3              0.000046 au BufNewFile,BufRead *.lss			setf lss
                            
                            " M4
    3              0.000055 au BufNewFile,BufRead *.m4
                            	\ if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
                            
                            " MaGic Point
    3              0.000051 au BufNewFile,BufRead *.mgp			setf mgp
                            
                            " Mail (for Elm, trn, mutt, muttng, rn, slrn)
    3              0.000579 au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
                            
                            " Mail aliases
    3              0.000177 au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases	setf mailaliases
                            
                            " Mailcap configuration file
    3              0.000110 au BufNewFile,BufRead .mailcap,mailcap		setf mailcap
                            
                            " Makefile
    3              0.000183 au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
                            
                            " MakeIndex
    3              0.000094 au BufNewFile,BufRead *.ist,*.mst		setf ist
                            
                            " Mallard
    3              0.000050 au BufNewFile,BufRead *.page			setf mallard
                            
                            " Manpage
    3              0.000049 au BufNewFile,BufRead *.man			setf man
                            
                            " Man config
    3              0.000095 au BufNewFile,BufRead */etc/man.conf,man.config	setf manconf
                            
                            " Maple V
    3              0.000132 au BufNewFile,BufRead *.mv,*.mpl,*.mws		setf maple
                            
                            " Map (UMN mapserver config file)
    3              0.000051 au BufNewFile,BufRead *.map			setf map
                            
                            " Markdown
    3              0.000250 au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
                            
                            " Mason
    3              0.000131 au BufNewFile,BufRead *.mason,*.mhtml,*.comp	setf mason
                            
                            " Matlab or Objective C
    3              0.000050 au BufNewFile,BufRead *.m			call s:FTm()
                            
    3              0.000016 func! s:FTm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|/\*\|//\)'
                                  setf objc
                                  return
                                endif
                                if line =~ '^\s*%'
                                  setf matlab
                                  return
                                endif
                                if line =~ '^\s*(\*'
                                  setf mma
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              if exists("g:filetype_m")
                                exe "setf " . g:filetype_m
                              else
                                setf matlab
                              endif
                            endfunc
                            
                            " Mathematica notebook
    3              0.000063 au BufNewFile,BufRead *.nb			setf mma
                            
                            " Maya Extension Language
    3              0.000056 au BufNewFile,BufRead *.mel			setf mel
                            
                            " Mercurial (hg) commit file
    3              0.000064 au BufNewFile,BufRead hg-editor-*.txt		setf hgcommit
                            
                            " Mercurial config (looks like generic config file)
    3              0.000105 au BufNewFile,BufRead *.hgrc,*hgrc		setf cfg
                            
                            " Messages (logs mostly)
    3              0.000125 au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
                            
                            " Metafont
    3              0.000055 au BufNewFile,BufRead *.mf			setf mf
                            
                            " MetaPost
    3              0.000050 au BufNewFile,BufRead *.mp			setf mp
                            
                            " MGL
    3              0.000055 au BufNewFile,BufRead *.mgl			setf mgl
                            
                            " MIX - Knuth assembly
    3              0.000095 au BufNewFile,BufRead *.mix,*.mixal		setf mix
                            
                            " MMIX or VMS makefile
    3              0.000053 au BufNewFile,BufRead *.mms			call s:FTmms()
                            
                            " Symbian meta-makefile definition (MMP)
    3              0.000076 au BufNewFile,BufRead *.mmp			setf mmp
                            
    3              0.000009 func! s:FTmms()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(%\|//\)' || line =~ '^\*'
                                  setf mmix
                                  return
                                endif
                                if line =~ '^\s*#'
                                  setf make
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf mmix
                            endfunc
                            
                            
                            " Modsim III (or LambdaProlog)
    3              0.000069 au BufNewFile,BufRead *.mod
                            	\ if getline(1) =~ '\<module\>' |
                            	\   setf lprolog |
                            	\ else |
                            	\   setf modsim3 |
                            	\ endif
                            
                            " Modula 2  (.md removed in favor of Markdown)
    3              0.000269 au BufNewFile,BufRead *.m2,*.DEF,*.MOD,*.mi	setf modula2
                            
                            " Modula 3 (.m3, .i3, .mg, .ig)
    3              0.000090 au BufNewFile,BufRead *.[mi][3g]		setf modula3
                            
                            " Monk
    3              0.000237 au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc	setf monk
                            
                            " MOO
    3              0.000072 au BufNewFile,BufRead *.moo			setf moo
                            
                            " Modconf
    3              0.000192 au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
                            
                            " Mplayer config
    3              0.000233 au BufNewFile,BufRead mplayer.conf,*/.mplayer/config	setf mplayerconf
                            
                            " Motorola S record
    3              0.000382 au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec	setf srec
                            
                            " Mrxvtrc
    3              0.000140 au BufNewFile,BufRead mrxvtrc,.mrxvtrc		setf mrxvtrc
                            
                            " Msql
    3              0.000069 au BufNewFile,BufRead *.msql			setf msql
                            
                            " Mysql
    3              0.000067 au BufNewFile,BufRead *.mysql			setf mysql
                            
                            " Mutt setup files (must be before catch *.rc)
    3              0.000073 au BufNewFile,BufRead */etc/Muttrc.d/*		call s:StarSetf('muttrc')
                            
                            " M$ Resource files
    3              0.000130 au BufNewFile,BufRead *.rc,*.rch		setf rc
                            
                            " MuPAD source
    3              0.000065 au BufRead,BufNewFile *.mu			setf mupad
                            
                            " Mush
    3              0.000062 au BufNewFile,BufRead *.mush			setf mush
                            
                            " Mutt setup file (also for Muttng)
    3              0.000074 au BufNewFile,BufRead Mutt{ng,}rc		setf muttrc
                            
                            " Nano
    3              0.000121 au BufNewFile,BufRead */etc/nanorc,*.nanorc  	setf nanorc
                            
                            " Nastran input/DMAP
                            "au BufNewFile,BufRead *.dat			setf nastran
                            
                            " Natural
    3              0.000080 au BufNewFile,BufRead *.NS[ACGLMNPS]		setf natural
                            
                            " Netrc
    3              0.000068 au BufNewFile,BufRead .netrc			setf netrc
                            
                            " Ninja file
    3              0.000079 au BufNewFile,BufRead *.ninja			setf ninja
                            
                            " Novell netware batch files
    3              0.000079 au BufNewFile,BufRead *.ncf			setf ncf
                            
                            " Nroff/Troff (*.ms and *.t are checked below)
    3              0.000078 au BufNewFile,BufRead *.me
                            	\ if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |
                            	\   setf nroff |
                            	\ endif
    3              0.000280 au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom	setf nroff
    3              0.000062 au BufNewFile,BufRead *.[1-9]			call s:FTnroff()
                            
                            " This function checks if one of the first five lines start with a dot.  In
                            " that case it is probably an nroff file: 'filetype' is set and 1 is returned.
    3              0.000011 func! s:FTnroff()
                              if getline(1)[0] . getline(2)[0] . getline(3)[0] . getline(4)[0] . getline(5)[0] =~ '\.'
                                setf nroff
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Nroff or Objective C++
    3              0.000066 au BufNewFile,BufRead *.mm			call s:FTmm()
                            
    3              0.000007 func! s:FTmm()
                              let n = 1
                              while n < 10
                                let line = getline(n)
                                if line =~ '^\s*\(#\s*\(include\|import\)\>\|/\*\)'
                                  setf objcpp
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf nroff
                            endfunc
                            
                            " Not Quite C
    3              0.000070 au BufNewFile,BufRead *.nqc			setf nqc
                            
                            " NSIS
    3              0.000112 au BufNewFile,BufRead *.nsi,*.nsh		setf nsis
                            
                            " OCAML
    3              0.000249 au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit	setf ocaml
                            
                            " Occam
    3              0.000063 au BufNewFile,BufRead *.occ			setf occam
                            
                            " Omnimark
    3              0.000109 au BufNewFile,BufRead *.xom,*.xin		setf omnimark
                            
                            " OpenROAD
    3              0.000073 au BufNewFile,BufRead *.or			setf openroad
                            
                            " OPL
    3              0.000062 au BufNewFile,BufRead *.[Oo][Pp][Ll]		setf opl
                            
                            " Oracle config file
    3              0.000059 au BufNewFile,BufRead *.ora			setf ora
                            
                            " Packet filter conf
    3              0.000056 au BufNewFile,BufRead pf.conf			setf pf
                            
                            " Pam conf
    3              0.000060 au BufNewFile,BufRead */etc/pam.conf		setf pamconf
                            
                            " PApp
    3              0.000136 au BufNewFile,BufRead *.papp,*.pxml,*.pxsl	setf papp
                            
                            " Password file
    3              0.000385 au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
                            
                            " Pascal (also *.p)
    3              0.000065 au BufNewFile,BufRead *.pas			setf pascal
                            
                            " Delphi project file
    3              0.000066 au BufNewFile,BufRead *.dpr			setf pascal
                            
                            " PDF
    3              0.000132 au BufNewFile,BufRead *.pdf			setf pdf
                            
                            " Perl
    3              0.000022 if has("fname_case")
                              au BufNewFile,BufRead *.pl,*.PL		call s:FTpl()
                            else
    3              0.000066   au BufNewFile,BufRead *.pl			call s:FTpl()
    3              0.000003 endif
    3              0.000109 au BufNewFile,BufRead *.plx,*.al		setf perl
    3              0.000108 au BufNewFile,BufRead *.p6,*.pm6		setf perl6
                            
    3              0.000009 func! s:FTpl()
                              if exists("g:filetype_pl")
                                exe "setf " . g:filetype_pl
                              else
                                " recognize Prolog by specific text in the first non-empty line
                                " require a blank after the '%' because Perl uses "%list" and "%translate"
                                let l = getline(nextnonblank(1))
                                if l =~ '\<prolog\>' || l =~ '^\s*\(%\+\(\s\|$\)\|/\*\)' || l =~ ':-'
                                  setf prolog
                                else
                                  setf perl
                                endif
                              endif
                            endfunc
                            
                            " Perl, XPM or XPM2
    3              0.000080 au BufNewFile,BufRead *.pm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ elseif getline(1) =~ "XPM" |
                            	\   setf xpm |
                            	\ else |
                            	\   setf perl |
                            	\ endif
                            
                            " Perl POD
    3              0.000061 au BufNewFile,BufRead *.pod			setf pod
                            
                            " Php, php3, php4, etc.
                            " Also Phtml (was used for PHP 2 in the past)
                            " Also .ctp for Cake template file
    3              0.000266 au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp	setf php
                            
                            " Pike
    3              0.000204 au BufNewFile,BufRead *.pike,*.lpc,*.ulpc,*.pmod setf pike
                            
                            " Pinfo config
    3              0.000161 au BufNewFile,BufRead */etc/pinforc,*/.pinforc	setf pinfo
                            
                            " Palm Resource compiler
    3              0.000068 au BufNewFile,BufRead *.rcp			setf pilrc
                            
                            " Pine config
    3              0.000202 au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex		setf pine
                            
                            " PL/1, PL/I
    3              0.000110 au BufNewFile,BufRead *.pli,*.pl1		setf pli
                            
                            " PL/M (also: *.inp)
    3              0.000152 au BufNewFile,BufRead *.plm,*.p36,*.pac		setf plm
                            
                            " PL/SQL
    3              0.000106 au BufNewFile,BufRead *.pls,*.plsql		setf plsql
                            
                            " PLP
    3              0.000063 au BufNewFile,BufRead *.plp			setf plp
                            
                            " PO and PO template (GNU gettext)
    3              0.000109 au BufNewFile,BufRead *.po,*.pot		setf po
                            
                            " Postfix main config
    3              0.000071 au BufNewFile,BufRead main.cf			setf pfmain
                            
                            " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
    3              0.000328 au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai	  setf postscr
                            
                            " PostScript Printer Description
    3              0.000069 au BufNewFile,BufRead *.ppd			setf ppd
                            
                            " Povray
    3              0.000061 au BufNewFile,BufRead *.pov			setf pov
                            
                            " Povray configuration
    3              0.000058 au BufNewFile,BufRead .povrayrc			setf povini
                            
                            " Povray, PHP or assembly
    3              0.000158 au BufNewFile,BufRead *.inc			call s:FTinc()
                            
    3              0.000016 func! s:FTinc()
                              if exists("g:filetype_inc")
                                exe "setf " . g:filetype_inc
                              else
                                let lines = getline(1).getline(2).getline(3)
                                if lines =~? "perlscript"
                                  setf aspperl
                                elseif lines =~ "<%"
                                  setf aspvbs
                                elseif lines =~ "<?"
                                  setf php
                                else
                                  call s:FTasmsyntax()
                                  if exists("b:asmsyntax")
                            	exe "setf " . fnameescape(b:asmsyntax)
                                  else
                            	setf pov
                                  endif
                                endif
                              endif
                            endfunc
                            
                            " Printcap and Termcap
    3              0.000098 au BufNewFile,BufRead *printcap
                            	\ let b:ptcap_type = "print" | setf ptcap
    3              0.000072 au BufNewFile,BufRead *termcap
                            	\ let b:ptcap_type = "term" | setf ptcap
                            
                            " PCCTS / ANTRL
                            "au BufNewFile,BufRead *.g			setf antrl
    3              0.000064 au BufNewFile,BufRead *.g			setf pccts
                            
                            " PPWizard
    3              0.000101 au BufNewFile,BufRead *.it,*.ih			setf ppwiz
                            
                            " Obj 3D file format
                            " TODO: is there a way to avoid MS-Windows Object files?
    3              0.000066 au BufNewFile,BufRead *.obj			setf obj
                            
                            " Oracle Pro*C/C++
    3              0.000066 au BufNewFile,BufRead *.pc			setf proc
                            
                            " Privoxy actions file
    3              0.000061 au BufNewFile,BufRead *.action			setf privoxy
                            
                            " Procmail
    3              0.000108 au BufNewFile,BufRead .procmail,.procmailrc	setf procmail
                            
                            " Progress or CWEB
    3              0.000056 au BufNewFile,BufRead *.w			call s:FTprogress_cweb()
                            
    3              0.000008 func! s:FTprogress_cweb()
                              if exists("g:filetype_w")
                                exe "setf " . g:filetype_w
                                return
                              endif
                              if getline(1) =~ '&ANALYZE' || getline(3) =~ '&GLOBAL-DEFINE'
                                setf progress
                              else
                                setf cweb
                              endif
                            endfunc
                            
                            " Progress or assembly
    3              0.000061 au BufNewFile,BufRead *.i			call s:FTprogress_asm()
                            
    3              0.000006 func! s:FTprogress_asm()
                              if exists("g:filetype_i")
                                exe "setf " . g:filetype_i
                                return
                              endif
                              " This function checks for an assembly comment the first ten lines.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*;' || line =~ '^\*'
                                  call s:FTasm()
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid assembly code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            " Progress or Pascal
    3              0.000065 au BufNewFile,BufRead *.p			call s:FTprogress_pascal()
                            
    3              0.000008 func! s:FTprogress_pascal()
                              if exists("g:filetype_p")
                                exe "setf " . g:filetype_p
                                return
                              endif
                              " This function checks for valid Pascal syntax in the first ten lines.
                              " Look for either an opening comment or a program start.
                              " If not found, assume Progress.
                              let lnum = 1
                              while lnum <= 10 && lnum < line('$')
                                let line = getline(lnum)
                                if line =~ '^\s*\(program\|unit\|procedure\|function\|const\|type\|var\)\>'
                            	\ || line =~ '^\s*{' || line =~ '^\s*(\*'
                                  setf pascal
                                  return
                                elseif line !~ '^\s*$' || line =~ '^/\*'
                                  " Not an empty line: Doesn't look like valid Pascal code.
                                  " Or it looks like a Progress /* comment
                                  break
                                endif
                                let lnum = lnum + 1
                              endw
                              setf progress
                            endfunc
                            
                            
                            " Software Distributor Product Specification File (POSIX 1387.2-1995)
    3              0.000074 au BufNewFile,BufRead *.psf			setf psf
    3              0.000130 au BufNewFile,BufRead INDEX,INFO
                            	\ if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |
                            	\   setf psf |
                            	\ endif
                            
                            " Prolog
    3              0.000068 au BufNewFile,BufRead *.pdb			setf prolog
                            
                            " Promela
    3              0.000063 au BufNewFile,BufRead *.pml			setf promela
                            
                            " Google protocol buffers
    3              0.000066 au BufNewFile,BufRead *.proto			setf proto
                            
                            " Protocols
    3              0.000063 au BufNewFile,BufRead */etc/protocols		setf protocols
                            
                            " Pyrex
    3              0.000115 au BufNewFile,BufRead *.pyx,*.pxd		setf pyrex
                            
                            " Python
    3              0.000111 au BufNewFile,BufRead *.py,*.pyw		setf python
                            
                            " Quixote (Python-based web framework)
    3              0.000062 au BufNewFile,BufRead *.ptl			setf python
                            
                            " Radiance
    3              0.000124 au BufNewFile,BufRead *.rad,*.mat		setf radiance
                            
                            " Ratpoison config/command files
    3              0.000114 au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc	setf ratpoison
                            
                            " RCS file
    3              0.000062 au BufNewFile,BufRead *\,v			setf rcs
                            
                            " Readline
    3              0.000111 au BufNewFile,BufRead .inputrc,inputrc		setf readline
                            
                            " Registry for MS-Windows
    3              0.000073 au BufNewFile,BufRead *.reg
                            	\ if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
                            
                            " Renderman Interface Bytestream
    3              0.000065 au BufNewFile,BufRead *.rib			setf rib
                            
                            " Rexx
    3              0.000484 au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit	setf rexx
                            
                            " R (Splus)
    3              0.000018 if has("fname_case")
                              au BufNewFile,BufRead *.s,*.S			setf r
                            else
    3              0.000065   au BufNewFile,BufRead *.s			setf r
    3              0.000003 endif
                            
                            " R Help file
    3              0.000010 if has("fname_case")
                              au BufNewFile,BufRead *.rd,*.Rd		setf rhelp
                            else
    3              0.000065   au BufNewFile,BufRead *.rd			setf rhelp
    3              0.000003 endif
                            
                            " R noweb file
    3              0.000012 if has("fname_case")
                              au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw		setf rnoweb
                            else
    3              0.000130   au BufNewFile,BufRead *.rnw,*.snw			setf rnoweb
    3              0.000003 endif
                            
                            " R Markdown file
    3              0.000010 if has("fname_case")
                              au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd		setf rmd
                            else
    3              0.000121   au BufNewFile,BufRead *.rmd,*.smd			setf rmd
    3              0.000003 endif
                            
                            " R reStructuredText file
    3              0.000009 if has("fname_case")
                              au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst	setf rrst
                            else
    3              0.000118   au BufNewFile,BufRead *.rrst,*.srst			setf rrst
    3              0.000003 endif
                            
                            " Rexx, Rebol or R
    3              0.000099 au BufNewFile,BufRead *.r,*.R			call s:FTr()
                            
    3              0.000006 func! s:FTr()
                              let max = line("$") > 50 ? 50 : line("$")
                            
                              for n in range(1, max)
                                " Rebol is easy to recognize, check for that first
                                if getline(n) =~? '\<REBOL\>'
                                  setf rebol
                                  return
                                endif
                              endfor
                            
                              for n in range(1, max)
                                " R has # comments
                                if getline(n) =~ '^\s*#'
                                  setf r
                                  return
                                endif
                                " Rexx has /* comments */
                                if getline(n) =~ '^\s*/\*'
                                  setf rexx
                                  return
                                endif
                              endfor
                            
                              " Nothing recognized, use user default or assume Rexx
                              if exists("g:filetype_r")
                                exe "setf " . g:filetype_r
                              else
                                " Rexx used to be the default, but R appears to be much more popular.
                                setf r
                              endif
                            endfunc
                            
                            " Remind
    3              0.000182 au BufNewFile,BufRead .reminders,*.remind,*.rem		setf remind
                            
                            " Resolv.conf
    3              0.000068 au BufNewFile,BufRead resolv.conf		setf resolv
                            
                            " Relax NG Compact
    3              0.000087 au BufNewFile,BufRead *.rnc			setf rnc
                            
                            " Relax NG XML
    3              0.000072 au BufNewFile,BufRead *.rng			setf rng
                            
                            " RPL/2
    3              0.000070 au BufNewFile,BufRead *.rpl			setf rpl
                            
                            " Robots.txt
    3              0.000063 au BufNewFile,BufRead robots.txt		setf robots
                            
                            " Rpcgen
    3              0.000060 au BufNewFile,BufRead *.x			setf rpcgen
                            
                            " reStructuredText Documentation Format
    3              0.000071 au BufNewFile,BufRead *.rst			setf rst
                            
                            " RTF
    3              0.000067 au BufNewFile,BufRead *.rtf			setf rtf
                            
                            " Interactive Ruby shell
    3              0.000124 au BufNewFile,BufRead .irbrc,irbrc		setf ruby
                            
                            " Ruby
    3              0.000123 au BufNewFile,BufRead *.rb,*.rbw		setf ruby
                            
                            " RubyGems
    3              0.000065 au BufNewFile,BufRead *.gemspec			setf ruby
                            
                            " Rackup
    3              0.000070 au BufNewFile,BufRead *.ru			setf ruby
                            
                            " Bundler
    3              0.000066 au BufNewFile,BufRead Gemfile			setf ruby
                            
                            " Ruby on Rails
    3              0.000183 au BufNewFile,BufRead *.builder,*.rxml,*.rjs	setf ruby
                            
                            " Rantfile and Rakefile is like Ruby
    3              0.000321 au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake	setf ruby
                            
                            " S-lang (or shader language, or SmallLisp)
    3              0.000173 au BufNewFile,BufRead *.sl			setf slang
                            
                            " Samba config
    3              0.000107 au BufNewFile,BufRead smb.conf			setf samba
                            
                            " SAS script
    3              0.000140 au BufNewFile,BufRead *.sas			setf sas
                            
                            " Sass
    3              0.000080 au BufNewFile,BufRead *.sass			setf sass
                            
                            " Sather
    3              0.000071 au BufNewFile,BufRead *.sa			setf sather
                            
                            " Scilab
    3              0.000183 au BufNewFile,BufRead *.sci,*.sce		setf scilab
                            
                            " SCSS
    3              0.000131 au BufNewFile,BufRead *.scss			setf scss
                            
                            " SD: Streaming Descriptors
    3              0.000082 au BufNewFile,BufRead *.sd			setf sd
                            
                            " SDL
    3              0.000129 au BufNewFile,BufRead *.sdl,*.pr		setf sdl
                            
                            " sed
    3              0.000083 au BufNewFile,BufRead *.sed			setf sed
                            
                            " Sieve (RFC 3028)
    3              0.000079 au BufNewFile,BufRead *.siv			setf sieve
                            
                            " Sendmail
    3              0.000072 au BufNewFile,BufRead sendmail.cf		setf sm
                            
                            " Sendmail .mc files are actually m4.  Could also be MS Message text file.
    3              0.000076 au BufNewFile,BufRead *.mc			call s:McSetf()
                            
    3              0.000012 func! s:McSetf()
                              " Rely on the file to start with a comment.
                              " MS message text files use ';', Sendmail files use '#' or 'dnl'
                              for lnum in range(1, min([line("$"), 20]))
                                let line = getline(lnum)
                                if line =~ '^\s*\(#\|dnl\)'
                                  setf m4  " Sendmail .mc file
                                  return
                                elseif line =~ '^\s*;'
                                  setf msmessages  " MS Message text file
                                  return
                                endif
                              endfor
                              setf m4  " Default: Sendmail .mc file
                            endfunc
                            
                            " Services
    3              0.000089 au BufNewFile,BufRead */etc/services		setf services
                            
                            " Service Location config
    3              0.000084 au BufNewFile,BufRead */etc/slp.conf		setf slpconf
                            
                            " Service Location registration
    3              0.000072 au BufNewFile,BufRead */etc/slp.reg		setf slpreg
                            
                            " Service Location SPI
    3              0.000078 au BufNewFile,BufRead */etc/slp.spi		setf slpspi
                            
                            " Setserial config
    3              0.000078 au BufNewFile,BufRead */etc/serial.conf		setf setserial
                            
                            " SGML
    3              0.000150 au BufNewFile,BufRead *.sgm,*.sgml
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |
                            	\   setf sgmllnx |
                            	\ elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |
                            	\   let b:docbk_type = "sgml" |
                            	\   let b:docbk_ver = 4 |
                            	\   setf docbk |
                            	\ else |
                            	\   setf sgml |
                            	\ endif
                            
                            " SGMLDECL
    3              0.000195 au BufNewFile,BufRead *.decl,*.dcl,*.dec
                            	\ if getline(1).getline(2).getline(3) =~? '^<!SGML' |
                            	\    setf sgmldecl |
                            	\ endif
                            
                            " SGML catalog file
    3              0.000070 au BufNewFile,BufRead catalog			setf catalog
    3              0.000073 au BufNewFile,BufRead sgml.catalog*		call s:StarSetf('catalog')
                            
                            " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
                            " Gentoo ebuilds are actually bash scripts
    3              0.000457 au BufNewFile,BufRead .bashrc*,bashrc,bash.bashrc,.bash_profile*,.bash_logout*,.bash_aliases*,*.bash,*.ebuild call SetFileTypeSH("bash")
    3              0.000134 au BufNewFile,BufRead .kshrc*,*.ksh call SetFileTypeSH("ksh")
    3              0.000245 au BufNewFile,BufRead */etc/profile,.profile*,*.sh,*.env call SetFileTypeSH(getline(1))
                            
                            " Also called from scripts.vim.
    3              0.000010 func! SetFileTypeSH(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              if a:name =~ '\<csh\>'
                                " Some .sh scripts contain #!/bin/csh.
                                call SetFileTypeShell("csh")
                                return
                              elseif a:name =~ '\<tcsh\>'
                                " Some .sh scripts contain #!/bin/tcsh.
                                call SetFileTypeShell("tcsh")
                                return
                              elseif a:name =~ '\<zsh\>'
                                " Some .sh scripts contain #!/bin/zsh.
                                call SetFileTypeShell("zsh")
                                return
                              elseif a:name =~ '\<ksh\>'
                                let b:is_kornshell = 1
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif exists("g:bash_is_sh") || a:name =~ '\<bash\>' || a:name =~ '\<bash2\>'
                                let b:is_bash = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_sh")
                                  unlet b:is_sh
                                endif
                              elseif a:name =~ '\<sh\>'
                                let b:is_sh = 1
                                if exists("b:is_kornshell")
                                  unlet b:is_kornshell
                                endif
                                if exists("b:is_bash")
                                  unlet b:is_bash
                                endif
                              endif
                              call SetFileTypeShell("sh")
                            endfunc
                            
                            " For shell-like file types, check for an "exec" command hidden in a comment,
                            " as used for Tcl.
                            " Also called from scripts.vim, thus can't be local to this script.
    3              0.000007 func! SetFileTypeShell(name)
                              if expand("<amatch>") =~ g:ft_ignore_pat
                                return
                              endif
                              let l = 2
                              while l < 20 && l < line("$") && getline(l) =~ '^\s*\(#\|$\)'
                                " Skip empty and comment lines.
                                let l = l + 1
                              endwhile
                              if l < line("$") && getline(l) =~ '\s*exec\s' && getline(l - 1) =~ '^\s*#.*\\$'
                                " Found an "exec" line after a comment with continuation
                                let n = substitute(getline(l),'\s*exec\s\+\([^ ]*/\)\=', '', '')
                                if n =~ '\<tclsh\|\<wish'
                                  setf tcl
                                  return
                                endif
                              endif
                              exe "setf " . a:name
                            endfunc
                            
                            " tcsh scripts
    3              0.000240 au BufNewFile,BufRead .tcshrc*,*.tcsh,tcsh.tcshrc,tcsh.login	call SetFileTypeShell("tcsh")
                            
                            " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
    3              0.000404 au BufNewFile,BufRead .login*,.cshrc*,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call s:CSH()
                            
    3              0.000006 func! s:CSH()
                              if exists("g:filetype_csh")
                                call SetFileTypeShell(g:filetype_csh)
                              elseif &shell =~ "tcsh"
                                call SetFileTypeShell("tcsh")
                              else
                                call SetFileTypeShell("csh")
                              endif
                            endfunc
                            
                            " Z-Shell script
    3              0.000194 au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
    3              0.000190 au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
    3              0.000086 au BufNewFile,BufRead *.zsh			setf zsh
                            
                            " Scheme
    3              0.000204 au BufNewFile,BufRead *.scm,*.ss,*.rkt		setf scheme
                            
                            " Screen RC
    3              0.000174 au BufNewFile,BufRead .screenrc,screenrc	setf screen
                            
                            " Simula
    3              0.000096 au BufNewFile,BufRead *.sim			setf simula
                            
                            " SINDA
    3              0.000134 au BufNewFile,BufRead *.sin,*.s85		setf sinda
                            
                            " SiSU
    3              0.000299 au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
    3              0.000194 au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
                            
                            " SKILL
    3              0.000220 au BufNewFile,BufRead *.il,*.ils,*.cdf		setf skill
                            
                            " SLRN
    3              0.000114 au BufNewFile,BufRead .slrnrc			setf slrnrc
    3              0.000113 au BufNewFile,BufRead *.score			setf slrnsc
                            
                            " Smalltalk (and TeX)
    3              0.000124 au BufNewFile,BufRead *.st			setf st
    3              0.000114 au BufNewFile,BufRead *.cls
                            	\ if getline(1) =~ '^%' |
                            	\  setf tex |
                            	\ elseif getline(1)[0] == '#' && getline(1) =~ 'rexx' |
                            	\  setf rexx |
                            	\ else |
                            	\  setf st |
                            	\ endif
                            
                            " Smarty templates
    3              0.000093 au BufNewFile,BufRead *.tpl			setf smarty
                            
                            " SMIL or XML
    3              0.000088 au BufNewFile,BufRead *.smil
                            	\ if getline(1) =~ '<?\s*xml.*?>' |
                            	\   setf xml |
                            	\ else |
                            	\   setf smil |
                            	\ endif
                            
                            " SMIL or SNMP MIB file
    3              0.000103 au BufNewFile,BufRead *.smi
                            	\ if getline(1) =~ '\<smil\>' |
                            	\   setf smil |
                            	\ else |
                            	\   setf mib |
                            	\ endif
                            
                            " SMITH
    3              0.000143 au BufNewFile,BufRead *.smt,*.smith		setf smith
                            
                            " Snobol4 and spitbol
    3              0.000150 au BufNewFile,BufRead *.sno,*.spt		setf snobol4
                            
                            " SNMP MIB files
    3              0.000150 au BufNewFile,BufRead *.mib,*.my		setf mib
                            
                            " Snort Configuration
    3              0.000207 au BufNewFile,BufRead *.hog,snort.conf,vision.conf	setf hog
    3              0.000088 au BufNewFile,BufRead *.rules			call s:FTRules()
                            
    3              0.000022 let s:ft_rules_udev_rules_pattern = '^\s*\cudev_rules\s*=\s*"\([^"]\{-1,}\)/*".*'
    3              0.000009 func! s:FTRules()
                              let path = expand('<amatch>:p')
                              if path =~ '^/\(etc/udev/\%(rules\.d/\)\=.*\.rules\|lib/udev/\%(rules\.d/\)\=.*\.rules\)$'
                                setf udevrules
                                return
                              endif
                              if path =~ '^/etc/ufw/'
                                setf conf  " Better than hog
                                return
                              endif
                              if path =~ '^/\(etc\|usr/share\)/polkit-1/rules\.d'
                                setf javascript
                                return
                              endif
                              try
                                let config_lines = readfile('/etc/udev/udev.conf')
                              catch /^Vim\%((\a\+)\)\=:E484/
                                setf hog
                                return
                              endtry
                              let dir = expand('<amatch>:p:h')
                              for line in config_lines
                                if line =~ s:ft_rules_udev_rules_pattern
                                  let udev_rules = substitute(line, s:ft_rules_udev_rules_pattern, '\1', "")
                                  if dir == udev_rules
                                    setf udevrules
                                  endif
                                  break
                                endif
                              endfor
                              setf hog
                            endfunc
                            
                            
                            " Spec (Linux RPM)
    3              0.000095 au BufNewFile,BufRead *.spec			setf spec
                            
                            " Speedup (AspenTech plant simulator)
    3              0.000209 au BufNewFile,BufRead *.speedup,*.spdata,*.spd	setf spup
                            
                            " Slice
    3              0.000091 au BufNewFile,BufRead *.ice			setf slice
                            
                            " Spice
    3              0.000146 au BufNewFile,BufRead *.sp,*.spice		setf spice
                            
                            " Spyce
    3              0.000166 au BufNewFile,BufRead *.spy,*.spi		setf spyce
                            
                            " Squid
    3              0.000091 au BufNewFile,BufRead squid.conf		setf squid
                            
                            " SQL for Oracle Designer
    3              0.000363 au BufNewFile,BufRead *.tyb,*.typ,*.tyc,*.pkb,*.pks	setf sql
                            
                            " SQL
    3              0.000094 au BufNewFile,BufRead *.sql			call s:SQL()
                            
    3              0.000007 func! s:SQL()
                              if exists("g:filetype_sql")
                                exe "setf " . g:filetype_sql
                              else
                                setf sql
                              endif
                            endfunc
                            
                            " SQLJ
    3              0.000099 au BufNewFile,BufRead *.sqlj			setf sqlj
                            
                            " SQR
    3              0.000158 au BufNewFile,BufRead *.sqr,*.sqi		setf sqr
                            
                            " OpenSSH configuration
    3              0.000158 au BufNewFile,BufRead ssh_config,*/.ssh/config	setf sshconfig
                            
                            " OpenSSH server configuration
    3              0.000096 au BufNewFile,BufRead sshd_config		setf sshdconfig
                            
                            " Stata
    3              0.000464 au BufNewFile,BufRead *.ado,*.class,*.do,*.imata,*.mata   setf stata
                            
                            " SMCL
    3              0.000239 au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl	setf smcl
                            
                            " Stored Procedures
    3              0.000106 au BufNewFile,BufRead *.stp			setf stp
                            
                            " Standard ML
    3              0.000101 au BufNewFile,BufRead *.sml			setf sml
                            
                            " Sratus VOS command macro
    3              0.000097 au BufNewFile,BufRead *.cm			setf voscm
                            
                            " Sysctl
    3              0.000175 au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf	setf sysctl
                            
                            " Synopsys Design Constraints
    3              0.000105 au BufNewFile,BufRead *.sdc			setf sdc
                            
                            " Sudoers
    3              0.000166 au BufNewFile,BufRead */etc/sudoers,sudoers.tmp	setf sudoers
                            
                            " SVG (Scalable Vector Graphics)
    3              0.000111 au BufNewFile,BufRead *.svg			setf svg
                            
                            " If the file has an extension of 't' and is in a directory 't' or 'xt' then
                            " it is almost certainly a Perl test file.
                            " If the first line starts with '#' and contains 'perl' it's probably a Perl
                            " file.
                            " (Slow test) If a file contains a 'use' statement then it is almost certainly
                            " a Perl file.
    3              0.000009 func! s:FTperl()
                              let dirname = expand("%:p:h:t")
                              if expand("%:e") == 't' && (dirname == 't' || dirname == 'xt')
                                setf perl
                                return 1
                              endif
                              if getline(1)[0] == '#' && getline(1) =~ 'perl'
                                setf perl
                                return 1
                              endif
                              if search('^use\s\s*\k', 'nc', 30)
                                setf perl
                                return 1
                              endif
                              return 0
                            endfunc
                            
                            " Tads (or Nroff or Perl test file)
    3              0.000103 au BufNewFile,BufRead *.t
                            	\ if !s:FTnroff() && !s:FTperl() | setf tads | endif
                            
                            " Tags
    3              0.000093 au BufNewFile,BufRead tags			setf tags
                            
                            " TAK
    3              0.000111 au BufNewFile,BufRead *.tak			setf tak
                            
                            " Task
    3              0.000107 au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
    3              0.000099 au BufRead,BufNewFile *.task			setf taskedit
                            
                            " Tcl (JACL too)
    3              0.000359 au BufNewFile,BufRead *.tcl,*.tk,*.itcl,*.itk,*.jacl	setf tcl
                            
                            " TealInfo
    3              0.000104 au BufNewFile,BufRead *.tli			setf tli
                            
                            " Telix Salt
    3              0.000106 au BufNewFile,BufRead *.slt			setf tsalt
                            
                            " Terminfo
    3              0.000113 au BufNewFile,BufRead *.ti			setf terminfo
                            
                            " TeX
    3              0.000387 au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl	setf tex
    3              0.000101 au BufNewFile,BufRead *.tex			call s:FTtex()
                            
                            " Choose context, plaintex, or tex (LaTeX) based on these rules:
                            " 1. Check the first line of the file for "%&<format>".
                            " 2. Check the first 1000 non-comment lines for LaTeX or ConTeXt keywords.
                            " 3. Default to "latex" or to g:tex_flavor, can be set in user's vimrc.
    3              0.000008 func! s:FTtex()
                              let firstline = getline(1)
                              if firstline =~ '^%&\s*\a\+'
                                let format = tolower(matchstr(firstline, '\a\+'))
                                let format = substitute(format, 'pdf', '', '')
                                if format == 'tex'
                                  let format = 'plain'
                                endif
                              else
                                " Default value, may be changed later:
                                let format = exists("g:tex_flavor") ? g:tex_flavor : 'plain'
                                " Save position, go to the top of the file, find first non-comment line.
                                let save_cursor = getpos('.')
                                call cursor(1,1)
                                let firstNC = search('^\s*[^[:space:]%]', 'c', 1000)
                                if firstNC " Check the next thousand lines for a LaTeX or ConTeXt keyword.
                                  let lpat = 'documentclass\>\|usepackage\>\|begin{\|newcommand\>\|renewcommand\>'
                                  let cpat = 'start\a\+\|setup\a\+\|usemodule\|enablemode\|enableregime\|setvariables\|useencoding\|usesymbols\|stelle\a\+\|verwende\a\+\|stel\a\+\|gebruik\a\+\|usa\a\+\|imposta\a\+\|regle\a\+\|utilisemodule\>'
                                  let kwline = search('^\s*\\\%(' . lpat . '\)\|^\s*\\\(' . cpat . '\)',
                            			      \ 'cnp', firstNC + 1000)
                                  if kwline == 1	" lpat matched
                            	let format = 'latex'
                                  elseif kwline == 2	" cpat matched
                            	let format = 'context'
                                  endif		" If neither matched, keep default set above.
                                  " let lline = search('^\s*\\\%(' . lpat . '\)', 'cn', firstNC + 1000)
                                  " let cline = search('^\s*\\\%(' . cpat . '\)', 'cn', firstNC + 1000)
                                  " if cline > 0
                                  "   let format = 'context'
                                  " endif
                                  " if lline > 0 && (cline == 0 || cline > lline)
                                  "   let format = 'tex'
                                  " endif
                                endif " firstNC
                                call setpos('.', save_cursor)
                              endif " firstline =~ '^%&\s*\a\+'
                            
                              " Translation from formats to file types.  TODO:  add AMSTeX, RevTex, others?
                              if format == 'plain'
                                setf plaintex
                              elseif format == 'context'
                                setf context
                              else " probably LaTeX
                                setf tex
                              endif
                              return
                            endfunc
                            
                            " ConTeXt
    3              0.000257 au BufNewFile,BufRead tex/context/*/*.tex,*.mkii,*.mkiv   setf context
                            
                            " Texinfo
    3              0.000245 au BufNewFile,BufRead *.texinfo,*.texi,*.txi	setf texinfo
                            
                            " TeX configuration
    3              0.000098 au BufNewFile,BufRead texmf.cnf			setf texmf
                            
                            " Tidy config
    3              0.000156 au BufNewFile,BufRead .tidyrc,tidyrc		setf tidy
                            
                            " TF mud client
    3              0.000238 au BufNewFile,BufRead *.tf,.tfrc,tfrc		setf tf
                            
                            " TPP - Text Presentation Program
    3              0.000113 au BufNewFile,BufReadPost *.tpp			setf tpp
                            
                            " Treetop
    3              0.000089 au BufRead,BufNewFile *.treetop			setf treetop
                            
                            " Trustees
    3              0.000081 au BufNewFile,BufRead trustees.conf		setf trustees
                            
                            " TSS - Geometry
    3              0.000098 au BufNewFile,BufReadPost *.tssgm		setf tssgm
                            
                            " TSS - Optics
    3              0.000093 au BufNewFile,BufReadPost *.tssop		setf tssop
                            
                            " TSS - Command Line (temporary)
    3              0.000089 au BufNewFile,BufReadPost *.tsscl		setf tsscl
                            
                            " TWIG files
    3              0.000095 au BufNewFile,BufReadPost *.twig		setf twig
                            
                            " Motif UIT/UIL files
    3              0.000186 au BufNewFile,BufRead *.uit,*.uil		setf uil
                            
                            " Udev conf
    3              0.000104 au BufNewFile,BufRead */etc/udev/udev.conf	setf udevconf
                            
                            " Udev permissions
    3              0.000112 au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
                            "
                            " Udev symlinks config
    3              0.000101 au BufNewFile,BufRead */etc/udev/cdsymlinks.conf	setf sh
                            
                            " UnrealScript
    3              0.000093 au BufNewFile,BufRead *.uc			setf uc
                            
                            " Updatedb
    3              0.000262 au BufNewFile,BufRead */etc/updatedb.conf	setf updatedb
                            
                            " Upstart (init(8)) config files
    3              0.000178 au BufNewFile,BufRead */usr/share/upstart/*.conf	       setf upstart
    3              0.000175 au BufNewFile,BufRead */usr/share/upstart/*.override	       setf upstart
    3              0.000171 au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
    3              0.000276 au BufNewFile,BufRead */.init/*.conf,*/.init/*.override        setf upstart
    3              0.000169 au BufNewFile,BufRead */.config/upstart/*.conf		       setf upstart
    3              0.000159 au BufNewFile,BufRead */.config/upstart/*.override	       setf upstart
                            
                            " Vera
    3              0.000376 au BufNewFile,BufRead *.vr,*.vri,*.vrh		setf vera
                            
                            " Verilog HDL
    3              0.000127 au BufNewFile,BufRead *.v			setf verilog
                            
                            " Verilog-AMS HDL
    3              0.000232 au BufNewFile,BufRead *.va,*.vams		setf verilogams
                            
                            " SystemVerilog
    3              0.000243 au BufNewFile,BufRead *.sv,*.svh		setf systemverilog
                            
                            " VHDL
    3              0.000523 au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst  setf vhdl
    3              0.000130 au BufNewFile,BufRead *.vhdl_[0-9]*		call s:StarSetf('vhdl')
                            
                            " Vim script
    3              0.000451 au BufNewFile,BufRead *.vim,*.vba,.exrc,_exrc	setf vim
                            
                            " Viminfo file
    3              0.000200 au BufNewFile,BufRead .viminfo,_viminfo		setf viminfo
                            
                            " Virata Config Script File or Drupal module
    3              0.000332 au BufRead,BufNewFile *.hw,*.module,*.pkg
                            	\ if getline(1) =~ '<?php' |
                            	\   setf php |
                            	\ else |
                            	\   setf virata |
                            	\ endif
                            
                            " Visual Basic (also uses *.bas) or FORM
    3              0.000167 au BufNewFile,BufRead *.frm			call s:FTVB("form")
                            
                            " SaxBasic is close to Visual Basic
    3              0.000149 au BufNewFile,BufRead *.sba			setf vb
                            
                            " Vgrindefs file
    3              0.000122 au BufNewFile,BufRead vgrindefs			setf vgrindefs
                            
                            " VRML V1.0c
    3              0.000125 au BufNewFile,BufRead *.wrl			setf vrml
                            
                            " Vroom (vim testing and executable documentation)
    3              0.000122 au BufNewFile,BufRead *.vroom			setf vroom
                            
                            " Webmacro
    3              0.000120 au BufNewFile,BufRead *.wm			setf webmacro
                            
                            " Wget config
    3              0.000198 au BufNewFile,BufRead .wgetrc,wgetrc		setf wget
                            
                            " Website MetaLanguage
    3              0.000131 au BufNewFile,BufRead *.wml			setf wml
                            
                            " Winbatch
    3              0.000130 au BufNewFile,BufRead *.wbt			setf winbatch
                            
                            " WSML
    3              0.000119 au BufNewFile,BufRead *.wsml			setf wsml
                            
                            " WvDial
    3              0.000202 au BufNewFile,BufRead wvdial.conf,.wvdialrc	setf wvdial
                            
                            " CVS RC file
    3              0.000116 au BufNewFile,BufRead .cvsrc			setf cvsrc
                            
                            " CVS commit file
    3              0.000122 au BufNewFile,BufRead cvs\d\+			setf cvs
                            
                            " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
                            " lines in a WEB file).
    3              0.000183 au BufNewFile,BufRead *.web
                            	\ if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |
                            	\   setf web |
                            	\ else |
                            	\   setf winbatch |
                            	\ endif
                            
                            " Windows Scripting Host and Windows Script Component
    3              0.000123 au BufNewFile,BufRead *.ws[fc]			setf wsh
                            
                            " XHTML
    3              0.000223 au BufNewFile,BufRead *.xhtml,*.xht		setf xhtml
                            
                            " X Pixmap (dynamically sets colors, use BufEnter to make it work better)
    3              0.000022 au BufEnter *.xpm
                            	\ if getline(1) =~ "XPM2" |
                            	\   setf xpm2 |
                            	\ else |
                            	\   setf xpm |
                            	\ endif
    3              0.000013 au BufEnter *.xpm2				setf xpm2
                            
                            " XFree86 config
    3              0.000137 au BufNewFile,BufRead XF86Config
                            	\ if getline(1) =~ '\<XConfigurator\>' |
                            	\   let b:xf86conf_xfree86_version = 3 |
                            	\ endif |
                            	\ setf xf86conf
    3              0.000135 au BufNewFile,BufRead */xorg.conf.d/*.conf
                            	\ let b:xf86conf_xfree86_version = 4 |
                            	\ setf xf86conf
                            
                            " Xorg config
    3              0.000201 au BufNewFile,BufRead xorg.conf,xorg.conf-4	let b:xf86conf_xfree86_version = 4 | setf xf86conf
                            
                            " Xinetd conf
    3              0.000143 au BufNewFile,BufRead */etc/xinetd.conf		setf xinetd
                            
                            " XS Perl extension interface language
    3              0.000121 au BufNewFile,BufRead *.xs			setf xs
                            
                            " X resources file
    3              0.000453 au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
                            
                            " Xmath
    3              0.000246 au BufNewFile,BufRead *.msc,*.msf		setf xmath
    3              0.000134 au BufNewFile,BufRead *.ms
                            	\ if !s:FTnroff() | setf xmath | endif
                            
                            " XML  specific variants: docbk and xbl
    3              0.000136 au BufNewFile,BufRead *.xml			call s:FTxml()
                            
    3              0.000020 func! s:FTxml()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                " DocBook 4 or DocBook 5.
                                let is_docbook4 = line =~ '<!DOCTYPE.*DocBook'
                                let is_docbook5 = line =~ ' xmlns="http://docbook.org/ns/docbook"'
                                if is_docbook4 || is_docbook5
                                  let b:docbk_type = "xml"
                                  if is_docbook5
                            	let b:docbk_ver = 5
                                  else
                            	let b:docbk_ver = 4
                                  endif
                                  setf docbk
                                  return
                                endif
                                if line =~ 'xmlns:xbl="http://www.mozilla.org/xbl"'
                                  setf xbl
                                  return
                                endif
                                let n += 1
                              endwhile
                              setf xml
                            endfunc
                            
                            " XMI (holding UML models) is also XML
    3              0.000194 au BufNewFile,BufRead *.xmi			setf xml
                            
                            " CSPROJ files are Visual Studio.NET's XML-based project config files
    3              0.000230 au BufNewFile,BufRead *.csproj,*.csproj.user	setf xml
                            
                            " Qt Linguist translation source and Qt User Interface Files are XML
    3              0.000225 au BufNewFile,BufRead *.ts,*.ui			setf xml
                            
                            " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
    3              0.000138 au BufNewFile,BufRead *.tpm			setf xml
                            
                            " Xdg menus
    3              0.000130 au BufNewFile,BufRead */etc/xdg/menus/*.menu	setf xml
                            
                            " ATI graphics driver configuration
    3              0.000155 au BufNewFile,BufRead fglrxrc			setf xml
                            
                            " XLIFF (XML Localisation Interchange File Format) is also XML
    3              0.000145 au BufNewFile,BufRead *.xlf			setf xml
    3              0.000135 au BufNewFile,BufRead *.xliff			setf xml
                            
                            " XML User Interface Language
    3              0.000299 au BufNewFile,BufRead *.xul			setf xml
                            
                            " X11 xmodmap (also see below)
    3              0.000331 au BufNewFile,BufRead *Xmodmap			setf xmodmap
                            
                            " Xquery
    3              0.001989 au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy	setf xquery
                            
                            " XSD
    3              0.000181 au BufNewFile,BufRead *.xsd			setf xsd
                            
                            " Xslt
    3              0.000258 au BufNewFile,BufRead *.xsl,*.xslt		setf xslt
                            
                            " Yacc
    3              0.000368 au BufNewFile,BufRead *.yy,*.yxx,*.y++		setf yacc
                            
                            " Yacc or racc
    3              0.000144 au BufNewFile,BufRead *.y			call s:FTy()
                            
    3              0.000021 func! s:FTy()
                              let n = 1
                              while n < 100 && n < line("$")
                                let line = getline(n)
                                if line =~ '^\s*%'
                                  setf yacc
                                  return
                                endif
                                if getline(n) =~ '^\s*\(#\|class\>\)' && getline(n) !~ '^\s*#\s*include'
                                  setf racc
                                  return
                                endif
                                let n = n + 1
                              endwhile
                              setf yacc
                            endfunc
                            
                            
                            " Yaml
    3              0.000256 au BufNewFile,BufRead *.yaml,*.yml		setf yaml
                            
                            " yum conf (close enough to dosini)
    3              0.000146 au BufNewFile,BufRead */etc/yum.conf		setf dosini
                            
                            " Zimbu
    3              0.000141 au BufNewFile,BufRead *.zu			setf zimbu
                            " Zimbu Templates
    3              0.000152 au BufNewFile,BufRead *.zut			setf zimbutempl
                            
                            " Zope
                            "   dtml (zope dynamic template markup language), pt (zope page template),
                            "   cpt (zope form controller page template)
    3              0.000350 au BufNewFile,BufRead *.dtml,*.pt,*.cpt		call s:FThtml()
                            "   zsql (zope sql method)
    3              0.000137 au BufNewFile,BufRead *.zsql			call s:SQL()
                            
                            " Z80 assembler asz80
    3              0.000152 au BufNewFile,BufRead *.z8a			setf z8a
                            
    3              0.000008 augroup END
                            
                            
                            " Source the user-specified filetype file, for backwards compatibility with
                            " Vim 5.x.
    3              0.000032 if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
                              execute "source " . myfiletypefile
                            endif
                            
                            
                            " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
                            " when there are no matching file name extensions.
                            " Don't do this for compressed files.
    3              0.000005 augroup filetypedetect
    3              0.000155 au BufNewFile,BufRead *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\ | runtime! scripts.vim | endif
    3              0.000020 au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
                            
                            
                            " Extra checks for when no filetype has been detected now.  Mostly used for
                            " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
                            " script file.
                            " Most of these should call s:StarSetf() to avoid names ending in .gz and the
                            " like are used.
                            
                            " More Apache config files
    3              0.000555 au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*	call s:StarSetf('apache')
    3              0.000698 au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.d/*.conf*		call s:StarSetf('apache')
                            
                            " Asterisk config file
    3              0.000161 au BufNewFile,BufRead *asterisk/*.conf*		call s:StarSetf('asterisk')
    3              0.000147 au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
                            
                            " Bazaar version control
    3              0.000264 au BufNewFile,BufRead bzr_log.*			setf bzr
                            
                            " BIND zone
    3              0.000246 au BufNewFile,BufRead */named/db.*,*/bind/db.*	call s:StarSetf('bindzone')
                            
                            " Calendar
    3              0.000422 au BufNewFile,BufRead */.calendar/*,
                            	\*/share/calendar/*/calendar.*,*/share/calendar/calendar.*
                            	\					call s:StarSetf('calendar')
                            
                            " Changelog
    3              0.000202 au BufNewFile,BufRead [cC]hange[lL]og*
                            	\ if getline(1) =~ '; urgency='
                            	\|  call s:StarSetf('debchangelog')
                            	\|else
                            	\|  call s:StarSetf('changelog')
                            	\|endif
                            
                            " Crontab
    3              0.000502 au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*		call s:StarSetf('crontab')
                            
                            " dnsmasq(8) configuration
    3              0.000163 au BufNewFile,BufRead */etc/dnsmasq.d/*		call s:StarSetf('dnsmasq')
                            
                            " Dracula
    3              0.000159 au BufNewFile,BufRead drac.*			call s:StarSetf('dracula')
                            
                            " Fvwm
    3              0.000138 au BufNewFile,BufRead */.fvwm/*			call s:StarSetf('fvwm')
    3              0.000244 au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook
                            	\ let b:fvwm_version = 1 | call s:StarSetf('fvwm')
    3              0.000195 au BufNewFile,BufRead *fvwm2rc*
                            	\ if expand("<afile>:e") == "m4"
                            	\|  call s:StarSetf('fvwm2m4')
                            	\|else
                            	\|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')
                            	\|endif
                            
                            " Gedcom
    3              0.000148 au BufNewFile,BufRead */tmp/lltmp*		call s:StarSetf('gedcom')
                            
                            " GTK RC
    3              0.000238 au BufNewFile,BufRead .gtkrc*,gtkrc*		call s:StarSetf('gtkrc')
                            
                            " Jam
    3              0.000233 au BufNewFile,BufRead Prl*.*,JAM*.*		call s:StarSetf('jam')
                            
                            " Jargon
    3              0.000153 au! BufNewFile,BufRead *jarg*
                            	\ if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'
                            	\|  call s:StarSetf('jargon')
                            	\|endif
                            
                            " Kconfig
    3              0.000145 au BufNewFile,BufRead Kconfig.*			call s:StarSetf('kconfig')
                            
                            " Lilo: Linux loader
    3              0.000141 au BufNewFile,BufRead lilo.conf*		call s:StarSetf('lilo')
                            
                            " Logcheck
    3              0.000155 au BufNewFile,BufRead */etc/logcheck/*.d*/*	call s:StarSetf('logcheck')
                            
                            " Makefile
    3              0.000129 au BufNewFile,BufRead [mM]akefile*		call s:StarSetf('make')
                            
                            " Ruby Makefile
    3              0.000131 au BufNewFile,BufRead [rR]akefile*		call s:StarSetf('ruby')
                            
                            " Mail (also matches muttrc.vim, so this is below the other checks)
    3              0.000161 au BufNewFile,BufRead mutt[[:alnum:]._-]\\\{6\}	setf mail
                            
                            " Modconf
    3              0.000322 au BufNewFile,BufRead */etc/modutils/*
                            	\ if executable(expand("<afile>")) != 1
                            	\|  call s:StarSetf('modconf')
                            	\|endif
    3              0.000152 au BufNewFile,BufRead */etc/modprobe.*		call s:StarSetf('modconf')
                            
                            " Mutt setup file
    3              0.000225 au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*	call s:StarSetf('muttrc')
    3              0.000216 au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*		call s:StarSetf('muttrc')
                            
                            " Nroff macros
    3              0.000131 au BufNewFile,BufRead tmac.*			call s:StarSetf('nroff')
                            
                            " Pam conf
    3              0.000137 au BufNewFile,BufRead */etc/pam.d/*		call s:StarSetf('pamconf')
                            
                            " Printcap and Termcap
    3              0.000135 au BufNewFile,BufRead *printcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')
                            	\|endif
    3              0.000142 au BufNewFile,BufRead *termcap*
                            	\ if !did_filetype()
                            	\|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')
                            	\|endif
                            
                            " ReDIF
                            " Only used when the .rdf file was not detected to be XML.
    3              0.000145 au BufRead,BufNewFile *.rdf			call s:Redif()
    3              0.000020 func! s:Redif()
                              let lnum = 1
                              while lnum <= 5 && lnum < line('$')
                                if getline(lnum) =~ "^\ctemplate-type:"
                                  setf redif
                                  return
                                endif
                                let lnum = lnum + 1
                              endwhile
                            endfunc
                            
                            " Remind
    3              0.000128 au BufNewFile,BufRead .reminders*		call s:StarSetf('remind')
                            
                            " Vim script
    3              0.000136 au BufNewFile,BufRead *vimrc*			call s:StarSetf('vim')
                            
                            " Subversion commit file
    3              0.000137 au BufNewFile,BufRead svn-commit*.tmp		setf svn
                            
                            " X resources file
    3              0.000303 au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
                            
                            " XFree86 config
    3              0.000148 au BufNewFile,BufRead XF86Config-4*
                            	\ let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
    3              0.000132 au BufNewFile,BufRead XF86Config*
                            	\ if getline(1) =~ '\<XConfigurator\>'
                            	\|  let b:xf86conf_xfree86_version = 3
                            	\|endif
                            	\|call s:StarSetf('xf86conf')
                            
                            " X11 xmodmap
    3              0.000127 au BufNewFile,BufRead *xmodmap*			call s:StarSetf('xmodmap')
                            
                            " Xinetd conf
    3              0.000125 au BufNewFile,BufRead */etc/xinetd.d/*		call s:StarSetf('xinetd')
                            
                            " yum conf (close enough to dosini)
    3              0.000128 au BufNewFile,BufRead */etc/yum.repos.d/*	call s:StarSetf('dosini')
                            
                            " Z-Shell script
    3              0.000221 au BufNewFile,BufRead zsh*,zlog*		call s:StarSetf('zsh')
                            
                            
                            " Plain text files, needs to be far down to not override others.  This avoids
                            " the "conf" type being used if there is a line starting with '#'.
    3              0.000323 au BufNewFile,BufRead *.txt,*.text,README	setf text
                            
                            
                            " Use the filetype detect plugins.  They may overrule any of the previously
                            " detected filetypes.
    3              0.000992 runtime! ftdetect/*.vim
                            
                            " NOTE: The above command could have ended the filetypedetect autocmd group
                            " and started another one. Let's make sure it has ended to get to a consistent
                            " state.
    3              0.000007 augroup END
                            
                            " Generic configuration file (check this last, it's just guessing!)
    3              0.000169 au filetypedetect BufNewFile,BufRead,StdinReadPost *
                            	\ if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat
                            	\    && (getline(1) =~ '^#' || getline(2) =~ '^#' || getline(3) =~ '^#'
                            	\	|| getline(4) =~ '^#' || getline(5) =~ '^#') |
                            	\   setf conf |
                            	\ endif
                            
                            
                            " If the GUI is already running, may still need to install the Syntax menu.
                            " Don't do it when the 'M' flag is included in 'guioptions'.
    3              0.000074 if has("menu") && has("gui_running")
                                  \ && !exists("did_install_syntax_menu") && &guioptions !~# "M"
    1              0.000075   source <sfile>:p:h/menu.vim
    1              0.000002 endif
                            
                            " Function called for testing all functions defined here.  These are
                            " script-local, thus need to be executed here.
                            " Returns a string with error messages (hopefully empty).
    3              0.000011 func! TestFiletypeFuncs(testlist)
                              let output = ''
                              for f in a:testlist
                                try
                                  exe f
                                catch
                                  let output = output . "\n" . f . ": " . v:exception
                                endtry
                              endfor
                              return output
                            endfunc
                            
                            " Restore 'cpoptions'
    3              0.000033 let &cpo = s:cpo_save
    3              0.000013 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/menu.vim
Sourced 2 times
Total time:   0.061320
 Self time:   0.058146

count  total (s)   self (s)
    1   0.000179   0.000037 " Vim support file to define the default menus
                            " You can also use this as a start for your own set of menus.
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2014 May 22
                            
                            " Note that ":an" (short for ":anoremenu") is often used to make a menu work
                            " in all modes and avoid side effects from mappings defined by the user.
                            
                            " Make sure the '<' and 'C' flags are not included in 'cpoptions', otherwise
                            " <CR> would not be recognized.  See ":help 'cpoptions'".
    2              0.000043 let s:cpo_save = &cpo
    2              0.000027 set cpo&vim
                            
                            " Avoid installing the menus twice
    2              0.000018 if !exists("did_install_default_menus")
    2              0.000010 let did_install_default_menus = 1
                            
                            
    2              0.000015 if (exists("v:lang") || &langmenu != "")
                              " Try to find a menu translation file for the current language.
    2              0.000009   if &langmenu != ""
    2              0.000032     if &langmenu =~ "none"
    1              0.000004       let s:lang = ""
    1              0.000003     else
    1              0.000003       let s:lang = &langmenu
    1              0.000002     endif
    2              0.000014   else
                                let s:lang = v:lang
                              endif
                              " A language name must be at least two characters, don't accept "C"
    2              0.000019   if strlen(s:lang) > 1
                                " When the language does not include the charset add 'encoding'
    1              0.000019     if s:lang =~ '^\a\a$\|^\a\a_\a\a$'
    1              0.000008       let s:lang = s:lang . '.' . &enc
    1              0.000002     endif
                            
                                " We always use a lowercase name.
                                " Change "iso-8859" to "iso_8859" and "iso8859" to "iso_8859", some
                                " systems appear to use this.
                                " Change spaces to underscores.
    1              0.000049     let s:lang = substitute(tolower(s:lang), '\.iso-', ".iso_", "")
    1              0.000014     let s:lang = substitute(s:lang, '\.iso8859', ".iso_8859", "")
    1              0.000008     let s:lang = substitute(s:lang, " ", "_", "g")
                                " Remove "@euro", otherwise "LC_ALL=de_DE@euro gvim" will show English menus
    1              0.000007     let s:lang = substitute(s:lang, "@euro", "", "")
                                " Change "iso_8859-1" and "iso_8859-15" to "latin1", we always use the
                                " same menu file for them.
    1              0.000008     let s:lang = substitute(s:lang, 'iso_8859-15\=$', "latin1", "")
    1              0.000003     menutrans clear
    1              0.000139     exe "runtime! lang/menu_" . s:lang . ".vim"
                            
    1              0.000007     if !exists("did_menu_trans")
                                  " There is no exact match, try matching with a wildcard added
                                  " (e.g. find menu_de_de.iso_8859-1.vim if s:lang == de_DE).
    1              0.000057       let s:lang = substitute(s:lang, '\.[^.]*', "", "")
    1              0.002790       exe "runtime! lang/menu_" . s:lang . "[^a-z]*vim"
                            
    1              0.000012       if !exists("did_menu_trans") && strlen($LANG) > 1 && s:lang !~ '^en_us'
                            	" On windows locale names are complicated, try using $LANG, it might
                            	" have been set by set_init_1().  But don't do this for "en" or "en_us".
                            	" But don't match "slovak" when $LANG is "sl".
                            	exe "runtime! lang/menu_" . tolower($LANG) . "[^a-z]*vim"
                                  endif
    1              0.000002     endif
    1              0.000002   endif
    2              0.000003 endif
                            
                            
                            " MacVim Window menu (should be next to Help so give it a high priority)
    2              0.000015 if has("gui_macvim")
    2              0.000057   an <silent> 9998.300 Window.Minimize		    <Nop>
    2              0.000019   an <silent> 9998.301 Window.Minimize\ All	    <Nop>
    2              0.000015   an <silent> 9998.310 Window.Zoom		    <Nop>
    2              0.000015   an <silent> 9998.311 Window.Zoom\ All		    <Nop>
    2              0.000041   an <silent> 9998.320 Window.Toggle\ Full\ Screen\ Mode :set invfullscreen<CR>
    2              0.000014   an 9998.330 Window.-SEP1-			    <Nop>
                              " TODO! Grey out if no tabs are visible.
    2              0.000024   an <silent> 9998.340 Window.Select\ Next\ Tab	    :tabnext<CR>
    2              0.000025   an <silent> 9998.350 Window.Select\ Previous\ Tab :tabprevious<CR>
    2              0.000013   an 9998.360 Window.-SEP2-			    <Nop>
    2              0.000017   an <silent> 9998.370 Window.Bring\ All\ To\ Front <Nop>
    2              0.000002 endif
                            
                            " Help menu
    2              0.000010 if has("gui_macvim")
    2              0.000025   an 9999.1 &Help.MacVim\ Help		    :h gui_mac<CR>
    2              0.000020   an <silent> 9999.2 Help.MacVim\ Website   <Nop>
    2              0.000014   an 9999.3 &Help.-sep0-		    <Nop>
    2              0.000004 endif
    2              0.000024 an 9999.10 &Help.&Overview<Tab><F1>	:help<CR>
    2              0.000022 an 9999.20 &Help.&User\ Manual		:help usr_toc<CR>
    2              0.000021 an 9999.30 &Help.&How-to\ links		:help how-to<CR>
    2              0.000087 an <silent> 9999.40 &Help.&Find\.\.\.	:call <SID>Helpfind()<CR>
    2              0.000012 an 9999.45 &Help.-sep1-			<Nop>
    2              0.000018 an 9999.50 &Help.&Credits		:help credits<CR>
    2              0.000018 an 9999.60 &Help.Co&pying		:help copying<CR>
    2              0.000032 an 9999.70 &Help.&Sponsor/Register	:help sponsor<CR>
    2              0.000019 an 9999.70 &Help.O&rphans		:help kcc<CR>
    2              0.000026 an 9999.75 &Help.-sep2-			<Nop>
    2              0.000015 an 9999.80 &Help.&Version		:version<CR>
    2              0.000015 an 9999.90 &Help.&About			:intro<CR>
                            
    2              0.000011 fun! s:Helpfind()
                              if !exists("g:menutrans_help_dialog")
                                let g:menutrans_help_dialog = "Enter a command or word to find help on:\n\nPrepend i_ for Input mode commands (e.g.: i_CTRL-X)\nPrepend c_ for command-line editing commands (e.g.: c_<Del>)\nPrepend ' for an option name (e.g.: 'shiftwidth')"
                              endif
                              let h = inputdialog(g:menutrans_help_dialog)
                              if h != ""
                                let v:errmsg = ""
                                silent! exe "help " . h
                                if v:errmsg != ""
                                  echo v:errmsg
                                endif
                              endif
                            endfun
                            
                            " File menu
    2              0.000021 if has("gui_macvim")
    2              0.000025   an <silent> 10.290 &File.New\ Window		    <Nop>
    2              0.000023   an  10.295 &File.New\ Tab			    :tabnew<CR>
    2              0.000117   an <silent> 10.310 &File.Open\.\.\.		    <Nop>
    2              0.000024   an <silent> 10.325 &File.Open\ Recent		    <Nop>
    2              0.000017   an 10.328 &File.-SEP0-			    <Nop>
    2              0.000025   an <silent> 10.330 &File.Close\ Window<Tab>:qa    :conf qa<CR>
    2              0.000019   an <silent> 10.332 &File.Close		    :conf q<CR>
    2              0.000022   an <silent> 10.341 &File.Save\ All		    :browse conf wa<CR>
    2              0.000025   an 10.350 &File.Save\ As\.\.\.<Tab>:sav	    :browse confirm saveas<CR>
    2              0.000005 else
                            endif
    2              0.000036 if !has("gui_macvim")
                              an 10.310 &File.&Open\.\.\.<Tab>:e		:browse confirm e<CR>
                            endif
    2              0.000057 an 10.320 &File.Sp&lit-Open\.\.\.<Tab>:sp	:browse sp<CR>
    2              0.000041 an 10.320 &File.Open\ Tab\.\.\.<Tab>:tabnew	:browse tabnew<CR>
    2              0.000016 if !has("gui_macvim")
                              an 10.325 &File.&New<Tab>:enew		:confirm enew<CR>
                              an <silent> 10.330 &File.&Close<Tab>:close
                            	\ :if winheight(2) < 0 && tabpagewinnr(2) == 0 <Bar>
                            	\   confirm enew <Bar>
                            	\ else <Bar>
                            	\   confirm close <Bar>
                            	\ endif<CR>
                            endif
    2              0.000016 an 10.335 &File.-SEP1-				<Nop>
    2              0.000045 an <silent> 10.340 &File.&Save<Tab>:w		:if expand("%") == ""<Bar>browse confirm w<Bar>else<Bar>confirm w<Bar>endif<CR>
    2              0.000028 an 10.350 &File.Save\ &As\.\.\.<Tab>:sav	:browse confirm saveas<CR>
                            
    2              0.000010 if has("diff")
    2              0.000014   an 10.400 &File.-SEP2-			<Nop>
    2              0.000027   an 10.410 &File.Split\ &Diff\ with\.\.\.	:browse vert diffsplit<CR>
    2              0.000080   an 10.420 &File.Split\ Patched\ &By\.\.\.	:browse vert diffpatch<CR>
    2              0.000007 endif
                            
    2              0.000014 if has("printer")
    2              0.000015   an 10.500 &File.-SEP3-			<Nop>
    2              0.000021   an 10.510 &File.&Print			:hardcopy<CR>
    2              0.000010   vunmenu   &File.&Print
    2              0.000017   vnoremenu &File.&Print			:hardcopy<CR>
    2              0.000007 elseif has("unix")
                              an 10.500 &File.-SEP3-			<Nop>
                              an 10.510 &File.&Print			:w !lpr<CR>
                              vunmenu   &File.&Print
                              vnoremenu &File.&Print			:w !lpr<CR>
                            endif
    2              0.000010 if !has("gui_macvim")
                              an 10.600 &File.-SEP4-				<Nop>
                              an 10.610 &File.Sa&ve-Exit<Tab>:wqa		:confirm wqa<CR>
                              an 10.620 &File.E&xit<Tab>:qa			:confirm qa<CR>
                            endif
                            
    2              0.000063 func! <SID>SelectAll()
                              exe "norm! gg" . (&slm == "" ? "VG" : "gH\<C-O>G")
                            endfunc
                            
    2              0.000017 func! s:FnameEscape(fname)
                              if exists('*fnameescape')
                                return fnameescape(a:fname)
                              endif
                              return escape(a:fname, " \t\n*?[{`$\\%#'\"|!<")
                            endfunc
                            
                            " Edit menu
    2              0.000033 an 20.310 &Edit.&Undo<Tab>u			u
    2              0.000052 an 20.320 &Edit.&Redo<Tab>^R			<C-R>
    2              0.000027 an 20.330 &Edit.Rep&eat<Tab>\.			.
                            
    2              0.000026 an 20.335 &Edit.-SEP1-				<Nop>
    2              0.000019 vnoremenu 20.340 &Edit.Cu&t<Tab>"+x		"+x
    2              0.000057 vnoremenu 20.350 &Edit.&Copy<Tab>"+y		"+y
    2              0.000043 cnoremenu 20.350 &Edit.&Copy<Tab>"+y		<C-Y>
    2              0.000018 nnoremenu 20.360 &Edit.&Paste<Tab>"+gP		"+gP
    2              0.000014 cnoremenu	 &Edit.&Paste<Tab>"+gP		<C-R>+
    2              0.000145 exe 'vnoremenu <script> &Edit.&Paste<Tab>"+gP	' . paste#paste_cmd['v']
    2              0.000031 exe 'inoremenu <script> &Edit.&Paste<Tab>"+gP	' . paste#paste_cmd['i']
    2              0.000018 nnoremenu 20.370 &Edit.Put\ &Before<Tab>[p	[p
    2              0.000014 inoremenu	 &Edit.Put\ &Before<Tab>[p	<C-O>[p
    2              0.000013 nnoremenu 20.380 &Edit.Put\ &After<Tab>]p	]p
    2              0.000011 inoremenu	 &Edit.Put\ &After<Tab>]p	<C-O>]p
    2              0.000019 if has("win32") || has("win16")
                              vnoremenu 20.390 &Edit.&Delete<Tab>x		x
                            endif
    2              0.000026 noremenu  <script> <silent> 20.400 &Edit.&Select\ All<Tab>ggVG	:<C-U>call <SID>SelectAll()<CR>
    2              0.000018 inoremenu <script> <silent> 20.400 &Edit.&Select\ All<Tab>ggVG	<C-O>:call <SID>SelectAll()<CR>
    2              0.000016 cnoremenu <script> <silent> 20.400 &Edit.&Select\ All<Tab>ggVG	<C-U>call <SID>SelectAll()<CR>
                            
    2              0.000012 an 20.405	 &Edit.-SEP2-				<Nop>
    2              0.000037 if has("win32") || has("win16") || has("gui_gtk") || has("gui_kde") || has("gui_motif")
                              an 20.410	 &Edit.&Find\.\.\.			:promptfind<CR>
                              vunmenu	 &Edit.&Find\.\.\.
                              vnoremenu <silent>	 &Edit.&Find\.\.\.		y:promptfind <C-R>=<SID>FixFText()<CR><CR>
                              an 20.420	 &Edit.Find\ and\ Rep&lace\.\.\.	:promptrepl<CR>
                              vunmenu	 &Edit.Find\ and\ Rep&lace\.\.\.
                              vnoremenu <silent>	 &Edit.Find\ and\ Rep&lace\.\.\. y:promptrepl <C-R>=<SID>FixFText()<CR><CR>
                            elseif has("gui_macvim")
    2              0.000095   an <silent> 20.410.10 &Edit.Find.Find\.\.\.	:promptfind<CR>
    2              0.000039   vunmenu &Edit.Find.Find\.\.\.
    2              0.000023   vnoremenu <silent> &Edit.Find.Find\.\.\.	y:promptfind <C-R>=<SID>FixFText()<CR><CR>
    2              0.000013   an 20.410.20 &Edit.Find.Find\ Next			<Nop>
    2              0.000014   an 20.410.30 &Edit.Find.Find\ Previous		<Nop>
    2              0.000021   vmenu 20.410.35 &Edit.Find.Use\ Selection\ for\ Find	y:let @/=@"<CR>:<BS>
    2              0.000002 else
                              an 20.410	 &Edit.&Find<Tab>/			/
                              an 20.420	 &Edit.Find\ and\ Rep&lace<Tab>:%s	:%s/
                              vunmenu	 &Edit.Find\ and\ Rep&lace<Tab>:%s
                              vnoremenu	 &Edit.Find\ and\ Rep&lace<Tab>:s	:s/
                            endif
                            
    2              0.000010 an 20.425	 &Edit.-SEP3-				<Nop>
    2              0.000018 an 20.430	 &Edit.Settings\ &Window		:options<CR>
    2              0.000019 an 20.435	 &Edit.Startup\ &Settings		:call <SID>EditVimrc()<CR>
                            
    2              0.000008 fun! s:EditVimrc()
                              if $MYVIMRC != ''
                                let fname = $MYVIMRC
                              elseif has("win32") || has("dos32") || has("dos16") || has("os2")
                                if $HOME != ''
                                  let fname = $HOME . "/_vimrc"
                                else
                                  let fname = $VIM . "/_vimrc"
                                endif
                              elseif has("amiga")
                                let fname = "s:.vimrc"
                              else
                                let fname = $HOME . "/.vimrc"
                              endif
                              let fname = s:FnameEscape(fname)
                              if &mod
                                exe "split " . fname
                              else
                                exe "edit " . fname
                              endif
                            endfun
                            
    2              0.000005 fun! s:FixFText()
                              " Fix text in nameless register to be used with :promptfind.
                              return substitute(@", "[\r\n]", '\\n', 'g')
                            endfun
                            
                            " Edit/Global Settings
    2              0.000035 an 20.440.100 &Edit.&Global\ Settings.Toggle\ Pattern\ &Highlight<Tab>:set\ hls!	:set hls! hls?<CR>
    2              0.000050 an 20.440.110 &Edit.&Global\ Settings.Toggle\ &Ignore-case<Tab>:set\ ic!	:set ic! ic?<CR>
    2              0.000031 an 20.440.110 &Edit.&Global\ Settings.Toggle\ &Showmatch<Tab>:set\ sm!	:set sm! sm?<CR>
                            
    2              0.000024 an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 1\  :set so=1<CR>
    2              0.000021 an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 2\  :set so=2<CR>
    2              0.000026 an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 3\  :set so=3<CR>
    2              0.000019 an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 4\  :set so=4<CR>
    2              0.000019 an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 5\  :set so=5<CR>
    2              0.000017 an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 7\  :set so=7<CR>
    2              0.000020 an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 10\  :set so=10<CR>
    2              0.000019 an 20.440.120 &Edit.&Global\ Settings.&Context\ lines.\ 100\  :set so=100<CR>
                            
    2              0.000023 an 20.440.130.40 &Edit.&Global\ Settings.&Virtual\ Edit.Never :set ve=<CR>
    2              0.000023 an 20.440.130.50 &Edit.&Global\ Settings.&Virtual\ Edit.Block\ Selection :set ve=block<CR>
    2              0.000023 an 20.440.130.60 &Edit.&Global\ Settings.&Virtual\ Edit.Insert\ mode :set ve=insert<CR>
    2              0.000025 an 20.440.130.70 &Edit.&Global\ Settings.&Virtual\ Edit.Block\ and\ Insert :set ve=block,insert<CR>
    2              0.000025 an 20.440.130.80 &Edit.&Global\ Settings.&Virtual\ Edit.Always :set ve=all<CR>
    2              0.000022 an 20.440.140 &Edit.&Global\ Settings.Toggle\ Insert\ &Mode<Tab>:set\ im!	:set im!<CR>
    2              0.000021 an 20.440.145 &Edit.&Global\ Settings.Toggle\ Vi\ C&ompatible<Tab>:set\ cp!	:set cp!<CR>
    2              0.000026 an <silent> 20.440.150 &Edit.&Global\ Settings.Search\ &Path\.\.\.  :call <SID>SearchP()<CR>
    2              0.000023 an <silent> 20.440.160 &Edit.&Global\ Settings.Ta&g\ Files\.\.\.  :call <SID>TagFiles()<CR>
                            "
                            " GUI options
    2              0.000013 an 20.440.300 &Edit.&Global\ Settings.-SEP1-				<Nop>
    2              0.000026 an <silent> 20.440.310 &Edit.&Global\ Settings.Toggle\ &Toolbar		:call <SID>ToggleGuiOption("T")<CR>
    2              0.000026 an <silent> 20.440.320 &Edit.&Global\ Settings.Toggle\ &Bottom\ Scrollbar :call <SID>ToggleGuiOption("b")<CR>
    2              0.000028 an <silent> 20.440.330 &Edit.&Global\ Settings.Toggle\ &Left\ Scrollbar	:call <SID>ToggleGuiOption("l")<CR>
    2              0.000025 an <silent> 20.440.340 &Edit.&Global\ Settings.Toggle\ &Right\ Scrollbar :call <SID>ToggleGuiOption("r")<CR>
                            
    2              0.000007 fun! s:SearchP()
                              if !exists("g:menutrans_path_dialog")
                                let g:menutrans_path_dialog = "Enter search path for files.\nSeparate directory names with a comma."
                              endif
                              let n = inputdialog(g:menutrans_path_dialog, substitute(&path, '\\ ', ' ', 'g'))
                              if n != ""
                                let &path = substitute(n, ' ', '\\ ', 'g')
                              endif
                            endfun
                            
    2              0.000006 fun! s:TagFiles()
                              if !exists("g:menutrans_tags_dialog")
                                let g:menutrans_tags_dialog = "Enter names of tag files.\nSeparate the names with a comma."
                              endif
                              let n = inputdialog(g:menutrans_tags_dialog, substitute(&tags, '\\ ', ' ', 'g'))
                              if n != ""
                                let &tags = substitute(n, ' ', '\\ ', 'g')
                              endif
                            endfun
                            
    2              0.000057 fun! s:ToggleGuiOption(option)
                                " If a:option is already set in guioptions, then we want to remove it
                                if match(&guioptions, "\\C" . a:option) > -1
                            	exec "set go-=" . a:option
                                else
                            	exec "set go+=" . a:option
                                endif
                            endfun
                            
                            " Edit/File Settings
                            
                            " Boolean options
    2              0.000039 an 20.440.100 &Edit.F&ile\ Settings.Toggle\ Line\ &Numbering<Tab>:set\ nu!	:set nu! nu?<CR>
    2              0.000027 an 20.440.105 &Edit.F&ile\ Settings.Toggle\ relati&ve\ Line\ Numbering<Tab>:set\ rnu!	:set rnu! rnu?<CR>
    2              0.000028 an 20.440.110 &Edit.F&ile\ Settings.Toggle\ &List\ Mode<Tab>:set\ list!	:set list! list?<CR>
    2              0.000066 an 20.440.120 &Edit.F&ile\ Settings.Toggle\ Line\ &Wrap<Tab>:set\ wrap!	:set wrap! wrap?<CR>
    2              0.000028 an 20.440.130 &Edit.F&ile\ Settings.Toggle\ W&rap\ at\ word<Tab>:set\ lbr!	:set lbr! lbr?<CR>
    2              0.000050 an 20.440.160 &Edit.F&ile\ Settings.Toggle\ &expand-tab<Tab>:set\ et!	:set et! et?<CR>
    2              0.000051 an 20.440.170 &Edit.F&ile\ Settings.Toggle\ &auto-indent<Tab>:set\ ai!	:set ai! ai?<CR>
    2              0.000033 an 20.440.180 &Edit.F&ile\ Settings.Toggle\ &C-indenting<Tab>:set\ cin!	:set cin! cin?<CR>
                            
                            " other options
    2              0.000015 an 20.440.600 &Edit.F&ile\ Settings.-SEP2-		<Nop>
    2              0.000022 an 20.440.610.20 &Edit.F&ile\ Settings.&Shiftwidth.2	:set sw=2 sw?<CR>
    2              0.000023 an 20.440.610.30 &Edit.F&ile\ Settings.&Shiftwidth.3	:set sw=3 sw?<CR>
    2              0.000019 an 20.440.610.40 &Edit.F&ile\ Settings.&Shiftwidth.4	:set sw=4 sw?<CR>
    2              0.000019 an 20.440.610.50 &Edit.F&ile\ Settings.&Shiftwidth.5	:set sw=5 sw?<CR>
    2              0.000046 an 20.440.610.60 &Edit.F&ile\ Settings.&Shiftwidth.6	:set sw=6 sw?<CR>
    2              0.000065 an 20.440.610.80 &Edit.F&ile\ Settings.&Shiftwidth.8	:set sw=8 sw?<CR>
                            
    2              0.000045 an 20.440.620.20 &Edit.F&ile\ Settings.Soft\ &Tabstop.2	:set sts=2 sts?<CR>
    2              0.000027 an 20.440.620.30 &Edit.F&ile\ Settings.Soft\ &Tabstop.3	:set sts=3 sts?<CR>
    2              0.000020 an 20.440.620.40 &Edit.F&ile\ Settings.Soft\ &Tabstop.4	:set sts=4 sts?<CR>
    2              0.000018 an 20.440.620.50 &Edit.F&ile\ Settings.Soft\ &Tabstop.5	:set sts=5 sts?<CR>
    2              0.000018 an 20.440.620.60 &Edit.F&ile\ Settings.Soft\ &Tabstop.6	:set sts=6 sts?<CR>
    2              0.000020 an 20.440.620.80 &Edit.F&ile\ Settings.Soft\ &Tabstop.8	:set sts=8 sts?<CR>
                            
    2              0.000025 an <silent> 20.440.630 &Edit.F&ile\ Settings.Te&xt\ Width\.\.\.  :call <SID>TextWidth()<CR>
    2              0.000026 an <silent> 20.440.640 &Edit.F&ile\ Settings.&File\ Format\.\.\.  :call <SID>FileFormat()<CR>
    2              0.000010 fun! s:TextWidth()
                              if !exists("g:menutrans_textwidth_dialog")
                                let g:menutrans_textwidth_dialog = "Enter new text width (0 to disable formatting): "
                              endif
                              let n = inputdialog(g:menutrans_textwidth_dialog, &tw)
                              if n != ""
                                " Remove leading zeros to avoid it being used as an octal number.
                                " But keep a zero by itself.
                                let tw = substitute(n, "^0*", "", "")
                                let &tw = tw == '' ? 0 : tw 
                              endif
                            endfun
                            
    2              0.000006 fun! s:FileFormat()
                              if !exists("g:menutrans_fileformat_dialog")
                                let g:menutrans_fileformat_dialog = "Select format for writing the file"
                              endif
                              if !exists("g:menutrans_fileformat_choices")
                                let g:menutrans_fileformat_choices = "&Unix\n&Dos\n&Mac\n&Cancel"
                              endif
                              if &ff == "dos"
                                let def = 2
                              elseif &ff == "mac"
                                let def = 3
                              else
                                let def = 1
                              endif
                              let n = confirm(g:menutrans_fileformat_dialog, g:menutrans_fileformat_choices, def, "Question")
                              if n == 1
                                set ff=unix
                              elseif n == 2
                                set ff=dos
                              elseif n == 3
                                set ff=mac
                              endif
                            endfun
                            
                            
                            " Setup the Edit.Color Scheme submenu
                            
                            " get NL separated string with file names
    2              0.002265 let s:n = globpath(&runtimepath, "colors/*.vim")
                            
                            " split at NL, Ignore case for VMS and windows, sort on name
    2              0.001862 let s:names = sort(map(split(s:n, "\n"), 'substitute(v:val, "\\c.*[/\\\\:\\]]\\([^/\\\\:]*\\)\\.vim", "\\1", "")'), 1)
                            
                            " define all the submenu entries
    2              0.000009 let s:idx = 100
   40              0.000069 for s:name in s:names
   38              0.000759   exe "an 20.450." . s:idx . ' &Edit.C&olor\ Scheme.' . s:name . " :colors " . s:name . "<CR>"
   38              0.000105   let s:idx = s:idx + 10
   38              0.000049 endfor
    2              0.000031 unlet s:name s:names s:n s:idx
                            
                            
                            " Setup the Edit.Keymap submenu
    2              0.000013 if has("keymap")
    2              0.006934   let s:n = globpath(&runtimepath, "keymap/*.vim")
    2              0.000030   if s:n != ""
    2              0.000011     let s:idx = 100
    2              0.000048     an 20.460.90 &Edit.&Keymap.None :set keymap=<CR>
  132              0.000653     while strlen(s:n) > 0
  130              0.000625       let s:i = stridx(s:n, "\n")
  130              0.000199       if s:i < 0
    2              0.000004 	let s:name = s:n
    2              0.000002 	let s:n = ""
    2              0.000002       else
  128              0.000624 	let s:name = strpart(s:n, 0, s:i)
  128              0.000698 	let s:n = strpart(s:n, s:i + 1, 19999)
  128              0.000171       endif
                                  " Ignore case for VMS and windows
  130              0.010894       let s:name = substitute(s:name, '\c.*[/\\:\]]\([^/\\:_]*\)\(_[0-9a-zA-Z-]*\)\=\.vim', '\1', '')
  130              0.003288       exe "an 20.460." . s:idx . ' &Edit.&Keymap.' . s:name . " :set keymap=" . s:name . "<CR>"
  130              0.000274       unlet s:name
  130              0.000191       unlet s:i
  130              0.000451       let s:idx = s:idx + 10
  130              0.000287     endwhile
    2              0.000006     unlet s:idx
    2              0.000002   endif
    2              0.000003   unlet s:n
    2              0.000002 endif
    2              0.000039 if has("win32") || has("win16") || has("gui_motif") || has("gui_gtk") || has("gui_kde") || has("gui_photon") || has("gui_mac")
                              an 20.470 &Edit.Select\ Fo&nt\.\.\.	:set guifont=*<CR>
                            elseif has("gui_macvim")
    2              0.000011   an 20.470 &Edit.-SEP4-                       <Nop>
    2              0.000011   an 20.475.10 &Edit.Font.Show\ Fonts          <Nop>
    2              0.000010   an 20.475.20 &Edit.Font.-SEP5-               <Nop>
    2              0.000008   an 20.475.30 &Edit.Font.Bigger               <Nop>
    2              0.000009   an 20.475.40 &Edit.Font.Smaller              <Nop>
    2              0.000009   an 20.480 &Edit.Special\ Characters\.\.\.    <Nop>
    2              0.000002 endif
                            
                            " Programming menu
    2              0.000007 if !exists("g:ctags_command")
    1              0.000004   if has("vms")
                                let g:ctags_command = "mc vim:ctags *.*"
                              else
    1              0.000002     let g:ctags_command = "ctags -R ."
    1              0.000001   endif
    1              0.000001 endif
                            
    2              0.000018 an 40.300 &Tools.&Jump\ to\ this\ tag<Tab>g^]	g<C-]>
    2              0.000007 vunmenu &Tools.&Jump\ to\ this\ tag<Tab>g^]
    2              0.000011 vnoremenu &Tools.&Jump\ to\ this\ tag<Tab>g^]	g<C-]>
    2              0.000011 an 40.310 &Tools.Jump\ &back<Tab>^T		<C-T>
    2              0.000017 an 40.320 &Tools.Build\ &Tags\ File		:exe "!" . g:ctags_command<CR>
                            
    2              0.000006 if has("folding") || has("spell")
    2              0.000007   an 40.330 &Tools.-SEP1-						<Nop>
    2              0.000002 endif
                            
                            " Tools.Spelling Menu
    2              0.000006 if has("spell")
    2              0.000017   an 40.335.110 &Tools.&Spelling.&Spell\ Check\ On		:set spell<CR>
    2              0.000015   an 40.335.120 &Tools.&Spelling.Spell\ Check\ &Off		:set nospell<CR>
    2              0.000013   an 40.335.130 &Tools.&Spelling.To\ &Next\ error<Tab>]s	]s
    2              0.000013   an 40.335.130 &Tools.&Spelling.To\ &Previous\ error<Tab>[s	[s
    2              0.000014   an 40.335.140 &Tools.&Spelling.Suggest\ &Corrections<Tab>z=	z=
    2              0.000016   an 40.335.150 &Tools.&Spelling.&Repeat\ correction<Tab>:spellrepall	:spellrepall<CR>
    2              0.000009   an 40.335.200 &Tools.&Spelling.-SEP1-				<Nop>
    2              0.000017   an 40.335.210 &Tools.&Spelling.Set\ language\ to\ "en"	:set spl=en spell<CR>
    2              0.000016   an 40.335.220 &Tools.&Spelling.Set\ language\ to\ "en_au"	:set spl=en_au spell<CR>
    2              0.000015   an 40.335.230 &Tools.&Spelling.Set\ language\ to\ "en_ca"	:set spl=en_ca spell<CR>
    2              0.000015   an 40.335.240 &Tools.&Spelling.Set\ language\ to\ "en_gb"	:set spl=en_gb spell<CR>
    2              0.000015   an 40.335.250 &Tools.&Spelling.Set\ language\ to\ "en_nz"	:set spl=en_nz spell<CR>
    2              0.000015   an 40.335.260 &Tools.&Spelling.Set\ language\ to\ "en_us"	:set spl=en_us spell<CR>
    2              0.000018   an <silent> 40.335.270 &Tools.&Spelling.&Find\ More\ Languages	:call <SID>SpellLang()<CR>
                            
    2              0.000009   let s:undo_spellang = ['aun &Tools.&Spelling.&Find\ More\ Languages']
    2              0.000009   func! s:SpellLang()
                                for cmd in s:undo_spellang
                                  exe "silent! " . cmd
                                endfor
                                let s:undo_spellang = []
                            
                                if &enc == "iso-8859-15"
                                  let enc = "latin1"
                                else
                                  let enc = &enc
                                endif
                            
                                if !exists("g:menutrans_set_lang_to")
                                  let g:menutrans_set_lang_to = 'Set language to'
                                endif
                            
                                let found = 0
                                let s = globpath(&rtp, "spell/*." . enc . ".spl")
                                if s != ""
                                  let n = 300
                                  for f in split(s, "\n")
                            	let nm = substitute(f, '.*spell[/\\]\(..\)\.[^/\\]*\.spl', '\1', "")
                            	if nm != "en" && nm !~ '/'
                                      let _nm = nm
                            	  let found += 1
                            	  let menuname = '&Tools.&Spelling.' . escape(g:menutrans_set_lang_to, "\\. \t|") . '\ "' . nm . '"'
                            	  exe 'an 40.335.' . n . ' ' . menuname . ' :set spl=' . nm . ' spell<CR>'
                            	  let s:undo_spellang += ['aun ' . menuname]
                            	endif
                            	let n += 10
                                  endfor
                                endif
                                if found == 0
                                  echomsg "Could not find other spell files"
                                elseif found == 1
                                  echomsg "Found spell file " . _nm
                                else
                                  echomsg "Found " . found . " more spell files"
                                endif
                                " Need to redo this when 'encoding' is changed.
                                augroup spellmenu
                                au! EncodingChanged * call <SID>SpellLang()
                                augroup END
                              endfun
                            
    2              0.000002 endif
                            
                            " Tools.Fold Menu
    2              0.000006 if has("folding")
                              " open close folds
    2              0.000016   an 40.340.110 &Tools.&Folding.&Enable/Disable\ folds<Tab>zi		zi
    2              0.000013   an 40.340.120 &Tools.&Folding.&View\ Cursor\ Line<Tab>zv		zv
    2              0.000019   an 40.340.120 &Tools.&Folding.Vie&w\ Cursor\ Line\ only<Tab>zMzx	zMzx
    2              0.000036   inoremenu 40.340.120 &Tools.&Folding.Vie&w\ Cursor\ Line\ only<Tab>zMzx  <C-O>zM<C-O>zx
    2              0.000013   an 40.340.130 &Tools.&Folding.C&lose\ more\ folds<Tab>zm		zm
    2              0.000011   an 40.340.140 &Tools.&Folding.&Close\ all\ folds<Tab>zM		zM
    2              0.000012   an 40.340.150 &Tools.&Folding.O&pen\ more\ folds<Tab>zr		zr
    2              0.000012   an 40.340.160 &Tools.&Folding.&Open\ all\ folds<Tab>zR		zR
                              " fold method
    2              0.000008   an 40.340.200 &Tools.&Folding.-SEP1-			<Nop>
    2              0.000018   an 40.340.210 &Tools.&Folding.Fold\ Met&hod.M&anual	:set fdm=manual<CR>
    2              0.000013   an 40.340.210 &Tools.&Folding.Fold\ Met&hod.I&ndent	:set fdm=indent<CR>
    2              0.000015   an 40.340.210 &Tools.&Folding.Fold\ Met&hod.E&xpression :set fdm=expr<CR>
    2              0.000018   an 40.340.210 &Tools.&Folding.Fold\ Met&hod.S&yntax	:set fdm=syntax<CR>
    2              0.000015   an 40.340.210 &Tools.&Folding.Fold\ Met&hod.&Diff	:set fdm=diff<CR>
    2              0.000015   an 40.340.210 &Tools.&Folding.Fold\ Met&hod.Ma&rker	:set fdm=marker<CR>
                              " create and delete folds
    2              0.000012   vnoremenu 40.340.220 &Tools.&Folding.Create\ &Fold<Tab>zf	zf
    2              0.000012   an 40.340.230 &Tools.&Folding.&Delete\ Fold<Tab>zd		zd
    2              0.000013   an 40.340.240 &Tools.&Folding.Delete\ &All\ Folds<Tab>zD	zD
                              " moving around in folds
    2              0.000009   an 40.340.300 &Tools.&Folding.-SEP2-				<Nop>
    2              0.000018   an 40.340.310.10 &Tools.&Folding.Fold\ col&umn\ width.\ &0\ 	:set fdc=0<CR>
    2              0.000015   an 40.340.310.20 &Tools.&Folding.Fold\ col&umn\ width.\ &2\ 	:set fdc=2<CR>
    2              0.000015   an 40.340.310.30 &Tools.&Folding.Fold\ col&umn\ width.\ &3\ 	:set fdc=3<CR>
    2              0.000016   an 40.340.310.40 &Tools.&Folding.Fold\ col&umn\ width.\ &4\ 	:set fdc=4<CR>
    2              0.000014   an 40.340.310.50 &Tools.&Folding.Fold\ col&umn\ width.\ &5\ 	:set fdc=5<CR>
    2              0.000013   an 40.340.310.60 &Tools.&Folding.Fold\ col&umn\ width.\ &6\ 	:set fdc=6<CR>
    2              0.000022   an 40.340.310.70 &Tools.&Folding.Fold\ col&umn\ width.\ &7\ 	:set fdc=7<CR>
    2              0.000013   an 40.340.310.80 &Tools.&Folding.Fold\ col&umn\ width.\ &8\ 	:set fdc=8<CR>
    2              0.000002 endif  " has folding
                            
    2              0.000006 if has("diff")
    2              0.000014   an 40.350.100 &Tools.&Diff.&Update		:diffupdate<CR>
    2              0.000013   an 40.350.110 &Tools.&Diff.&Get\ Block	:diffget<CR>
    2              0.000005   vunmenu &Tools.&Diff.&Get\ Block
    2              0.000009   vnoremenu &Tools.&Diff.&Get\ Block		:diffget<CR>
    2              0.000012   an 40.350.120 &Tools.&Diff.&Put\ Block	:diffput<CR>
    2              0.000005   vunmenu &Tools.&Diff.&Put\ Block
    2              0.000010   vnoremenu &Tools.&Diff.&Put\ Block		:diffput<CR>
    2              0.000002 endif
                            
    2              0.000008 an 40.358 &Tools.-SEP2-					<Nop>
    2              0.000011 an 40.360 &Tools.&Make<Tab>:make			:make<CR>
    2              0.000012 an 40.370 &Tools.&List\ Errors<Tab>:cl			:cl<CR>
    2              0.000014 an 40.380 &Tools.L&ist\ Messages<Tab>:cl!		:cl!<CR>
    2              0.000011 an 40.390 &Tools.&Next\ Error<Tab>:cn			:cn<CR>
    2              0.000013 an 40.400 &Tools.&Previous\ Error<Tab>:cp		:cp<CR>
    2              0.000011 an 40.410 &Tools.&Older\ List<Tab>:cold			:colder<CR>
    2              0.000010 an 40.420 &Tools.N&ewer\ List<Tab>:cnew			:cnewer<CR>
    2              0.000015 an 40.430.50 &Tools.Error\ &Window.&Update<Tab>:cwin	:cwin<CR>
    2              0.000013 an 40.430.60 &Tools.Error\ &Window.&Open<Tab>:copen	:copen<CR>
    2              0.000013 an 40.430.70 &Tools.Error\ &Window.&Close<Tab>:cclose	:cclose<CR>
                            
    2              0.000007 an 40.520 &Tools.-SEP3-					<Nop>
    2              0.000022 an <silent> 40.530 &Tools.&Convert\ to\ HEX<Tab>:%!xxd
                            	\ :call <SID>XxdConv()<CR>
    2              0.000017 an <silent> 40.540 &Tools.Conve&rt\ back<Tab>:%!xxd\ -r
                            	\ :call <SID>XxdBack()<CR>
                            
                            " Use a function to do the conversion, so that it also works with 'insertmode'
                            " set.
    2              0.000005 func! s:XxdConv()
                              let mod = &mod
                              if has("vms")
                                %!mc vim:xxd
                              else
                                call s:XxdFind()
                                exe '%!"' . g:xxdprogram . '"'
                              endif
                              if getline(1) =~ "^0000000:"		" only if it worked
                                set ft=xxd
                              endif
                              let &mod = mod
                            endfun
                            
    2              0.000004 func! s:XxdBack()
                              let mod = &mod
                              if has("vms")
                                %!mc vim:xxd -r
                              else
                                call s:XxdFind()
                                exe '%!"' . g:xxdprogram . '" -r'
                              endif
                              set ft=
                              doautocmd filetypedetect BufReadPost
                              let &mod = mod
                            endfun
                            
    2              0.000003 func! s:XxdFind()
                              if !exists("g:xxdprogram")
                                " On the PC xxd may not be in the path but in the install directory
                                if (has("win32") || has("dos32")) && !executable("xxd")
                                  let g:xxdprogram = $VIMRUNTIME . (&shellslash ? '/' : '\') . "xxd.exe"
                                else
                                  let g:xxdprogram = "xxd"
                                endif
                              endif
                            endfun
                            
                            " Setup the Tools.Compiler submenu
    2              0.003498 let s:n = globpath(&runtimepath, "compiler/*.vim")
    2              0.000013 let s:idx = 100
  118              0.000308 while strlen(s:n) > 0
  116              0.000397   let s:i = stridx(s:n, "\n")
  116              0.000119   if s:i < 0
    2              0.000003     let s:name = s:n
    2              0.000002     let s:n = ""
    2              0.000002   else
  114              0.000358     let s:name = strpart(s:n, 0, s:i)
  114              0.000421     let s:n = strpart(s:n, s:i + 1, 19999)
  114              0.000108   endif
                              " Ignore case for VMS and windows
  116              0.004107   let s:name = substitute(s:name, '\c.*[/\\:\]]\([^/\\:]*\)\.vim', '\1', '')
  116              0.001715   exe "an 30.440." . s:idx . ' &Tools.Se&T\ Compiler.' . s:name . " :compiler " . s:name . "<CR>"
  116              0.000189   unlet s:name
  116              0.000093   unlet s:i
  116              0.000205   let s:idx = s:idx + 10
  116              0.000088 endwhile
    2              0.000005 unlet s:n
    2              0.000004 unlet s:idx
                            
    2              0.000008 if !exists("no_buffers_menu")
                            
                            " Buffer list menu -- Setup functions & actions
                            
                            " wait with building the menu until after loading 'session' files. Makes
                            " startup faster.
    2              0.000004 let s:bmenu_wait = 1
                            
    2              0.000006 if !exists("bmenu_priority")
    1              0.000002   let bmenu_priority = 60
    1              0.000001 endif
                            
    2              0.000008 func! s:BMAdd()
                              if s:bmenu_wait == 0
                                " when adding too many buffers, redraw in short format
                                if s:bmenu_count == &menuitems && s:bmenu_short == 0
                                  call s:BMShow()
                                else
                                  call <SID>BMFilename(expand("<afile>"), expand("<abuf>"))
                                  let s:bmenu_count = s:bmenu_count + 1
                                endif
                              endif
                            endfunc
                            
    2              0.000005 func! s:BMRemove()
                              if s:bmenu_wait == 0
                                let name = expand("<afile>")
                                if isdirectory(name)
                                  return
                                endif
                                let munge = <SID>BMMunge(name, expand("<abuf>"))
                            
                                if s:bmenu_short == 0
                                  exe 'silent! aun &Buffers.' . munge
                                else
                                  exe 'silent! aun &Buffers.' . <SID>BMHash2(munge) . munge
                                endif
                                let s:bmenu_count = s:bmenu_count - 1
                              endif
                            endfunc
                            
                            " Create the buffer menu (delete an existing one first).
    2              0.000003 func! s:BMShow(...)
                              let s:bmenu_wait = 1
                              let s:bmenu_short = 1
                              let s:bmenu_count = 0
                              "
                              " get new priority, if exists
                              if a:0 == 1
                                let g:bmenu_priority = a:1
                              endif
                            
                              " remove old menu, if exists; keep one entry to avoid a torn off menu to
                              " disappear.
                              silent! unmenu &Buffers
                              exe 'noremenu ' . g:bmenu_priority . ".1 &Buffers.Dummy l"
                              silent! unmenu! &Buffers
                            
                              " create new menu; set 'cpo' to include the <CR>
                              let cpo_save = &cpo
                              set cpo&vim
                              exe 'an <silent> ' . g:bmenu_priority . ".2 &Buffers.&Refresh\\ menu :call <SID>BMShow()<CR>"
                              exe 'an ' . g:bmenu_priority . ".4 &Buffers.&Delete :confirm bd<CR>"
                              exe 'an ' . g:bmenu_priority . ".6 &Buffers.&Alternate :confirm b #<CR>"
                              exe 'an ' . g:bmenu_priority . ".7 &Buffers.&Next :confirm bnext<CR>"
                              exe 'an ' . g:bmenu_priority . ".8 &Buffers.&Previous :confirm bprev<CR>"
                              exe 'an ' . g:bmenu_priority . ".9 &Buffers.-SEP- :"
                              let &cpo = cpo_save
                              unmenu &Buffers.Dummy
                            
                              " figure out how many buffers there are
                              let buf = 1
                              while buf <= bufnr('$')
                                if bufexists(buf) && !isdirectory(bufname(buf)) && buflisted(buf)
                                  let s:bmenu_count = s:bmenu_count + 1
                                endif
                                let buf = buf + 1
                              endwhile
                              if s:bmenu_count <= &menuitems
                                let s:bmenu_short = 0
                              endif
                            
                              " iterate through buffer list, adding each buffer to the menu:
                              let buf = 1
                              while buf <= bufnr('$')
                                if bufexists(buf) && !isdirectory(bufname(buf)) && buflisted(buf)
                                  call <SID>BMFilename(bufname(buf), buf)
                                endif
                                let buf = buf + 1
                              endwhile
                              let s:bmenu_wait = 0
                              aug buffer_list
                              au!
                              au BufCreate,BufFilePost * call <SID>BMAdd()
                              au BufDelete,BufFilePre * call <SID>BMRemove()
                              aug END
                            endfunc
                            
    2              0.000005 func! s:BMHash(name)
                              " Make name all upper case, so that chars are between 32 and 96
                              let nm = substitute(a:name, ".*", '\U\0', "")
                              if has("ebcdic")
                                " HACK: Replace all non alphabetics with 'Z'
                                "       Just to make it work for now.
                                let nm = substitute(nm, "[^A-Z]", 'Z', "g")
                                let sp = char2nr('A') - 1
                              else
                                let sp = char2nr(' ')
                              endif
                              " convert first six chars into a number for sorting:
                              return (char2nr(nm[0]) - sp) * 0x800000 + (char2nr(nm[1]) - sp) * 0x20000 + (char2nr(nm[2]) - sp) * 0x1000 + (char2nr(nm[3]) - sp) * 0x80 + (char2nr(nm[4]) - sp) * 0x20 + (char2nr(nm[5]) - sp)
                            endfunc
                            
    2              0.000004 func! s:BMHash2(name)
                              let nm = substitute(a:name, ".", '\L\0', "")
                              " Not exactly right for EBCDIC...
                              if nm[0] < 'a' || nm[0] > 'z'
                                return '&others.'
                              elseif nm[0] <= 'd'
                                return '&abcd.'
                              elseif nm[0] <= 'h'
                                return '&efgh.'
                              elseif nm[0] <= 'l'
                                return '&ijkl.'
                              elseif nm[0] <= 'p'
                                return '&mnop.'
                              elseif nm[0] <= 't'
                                return '&qrst.'
                              else
                                return '&u-z.'
                              endif
                            endfunc
                            
                            " insert a buffer name into the buffer menu:
    2              0.000005 func! s:BMFilename(name, num)
                              if isdirectory(a:name)
                                return
                              endif
                              let munge = <SID>BMMunge(a:name, a:num)
                              let hash = <SID>BMHash(munge)
                              if s:bmenu_short == 0
                                let name = 'an ' . g:bmenu_priority . '.' . hash . ' &Buffers.' . munge
                              else
                                let name = 'an ' . g:bmenu_priority . '.' . hash . '.' . hash . ' &Buffers.' . <SID>BMHash2(munge) . munge
                              endif
                              " set 'cpo' to include the <CR>
                              let cpo_save = &cpo
                              set cpo&vim
                              exe name . ' :confirm b' . a:num . '<CR>'
                              let &cpo = cpo_save
                            endfunc
                            
                            " Truncate a long path to fit it in a menu item.
    2              0.000009 if !exists("g:bmenu_max_pathlen")
    1              0.000003   let g:bmenu_max_pathlen = 35
    1              0.000001 endif
    2              0.000005 func! s:BMTruncName(fname)
                              let name = a:fname
                              if g:bmenu_max_pathlen < 5
                                let name = ""
                              else
                                let len = strlen(name)
                                if len > g:bmenu_max_pathlen
                                  let amountl = (g:bmenu_max_pathlen / 2) - 2
                                  let amountr = g:bmenu_max_pathlen - amountl - 3
                                  let pattern = '^\(.\{,' . amountl . '}\).\{-}\(.\{,' . amountr . '}\)$'
                                  let left = substitute(name, pattern, '\1', '')
                                  let right = substitute(name, pattern, '\2', '')
                                  if strlen(left) + strlen(right) < len
                            	let name = left . '...' . right
                                  endif
                                endif
                              endif
                              return name
                            endfunc
                            
    2              0.000004 func! s:BMMunge(fname, bnum)
                              let name = a:fname
                              if name == ''
                                if !exists("g:menutrans_no_file")
                                  let g:menutrans_no_file = "[No file]"
                                endif
                                let name = g:menutrans_no_file
                              else
                                let name = fnamemodify(name, ':p:~')
                              endif
                              " detach file name and separate it out:
                              let name2 = fnamemodify(name, ':t')
                              if a:bnum >= 0
                                let name2 = name2 . ' (' . a:bnum . ')'
                              endif
                              let name = name2 . "\t" . <SID>BMTruncName(fnamemodify(name,':h'))
                              let name = escape(name, "\\. \t|")
                              let name = substitute(name, "&", "&&", "g")
                              let name = substitute(name, "\n", "^@", "g")
                              return name
                            endfunc
                            
                            " When just starting Vim, load the buffer menu later.  Don't do this for MacVim
                            " because it makes the menu flicker each time a new editor window is opened.
    2              0.000016 if has("vim_starting") && !has("gui_macvim")
                              augroup LoadBufferMenu
                                au! VimEnter * if !exists("no_buffers_menu") | call <SID>BMShow() | endif
                                au  VimEnter * au! LoadBufferMenu
                              augroup END
                            else
    2   0.002736   0.000040   call <SID>BMShow()
    2              0.000015 endif
                            
    2              0.000002 endif " !exists("no_buffers_menu")
                            
                            " Window menu
    2              0.000011 if !has("gui_macvim")
                            an 70.300 &Window.&New<Tab>^Wn			<C-W>n
                            an 70.310 &Window.S&plit<Tab>^Ws		<C-W>s
                            an 70.320 &Window.Sp&lit\ To\ #<Tab>^W^^	<C-W><C-^>
                            an 70.330 &Window.Split\ &Vertically<Tab>^Wv	<C-W>v
                            if has("vertsplit")
                              an <silent> 70.332 &Window.Split\ File\ E&xplorer	:call MenuExplOpen()<CR>
                              if !exists("*MenuExplOpen")
                                fun MenuExplOpen()
                                  if @% == ""
                            	20vsp .
                                  else
                            	exe "20vsp " . s:FnameEscape(expand("%:p:h"))
                                  endif
                                endfun
                              endif
                            endif
                            an 70.335 &Window.-SEP1-				<Nop>
                            an 70.340 &Window.&Close<Tab>^Wc			:confirm close<CR>
                            an 70.345 &Window.Close\ &Other(s)<Tab>^Wo		:confirm only<CR>
                            an 70.350 &Window.-SEP2-				<Nop>
                            an 70.355 &Window.Move\ &To.&Top<Tab>^WK		<C-W>K
                            an 70.355 &Window.Move\ &To.&Bottom<Tab>^WJ		<C-W>J
                            an 70.355 &Window.Move\ &To.&Left\ side<Tab>^WH		<C-W>H
                            an 70.355 &Window.Move\ &To.&Right\ side<Tab>^WL	<C-W>L
                            an 70.360 &Window.Rotate\ &Up<Tab>^WR			<C-W>R
                            an 70.362 &Window.Rotate\ &Down<Tab>^Wr			<C-W>r
                            an 70.365 &Window.-SEP3-				<Nop>
                            an 70.370 &Window.&Equal\ Size<Tab>^W=			<C-W>=
                            an 70.380 &Window.&Max\ Height<Tab>^W_			<C-W>_
                            an 70.390 &Window.M&in\ Height<Tab>^W1_			<C-W>1_
                            an 70.400 &Window.Max\ &Width<Tab>^W\|			<C-W>\|
                            an 70.410 &Window.Min\ Widt&h<Tab>^W1\|			<C-W>1\|
                            endif " !has("gui_macvim")
                            
                            " The popup menu
    2              0.000072 an 1.10 PopUp.&Undo			u
    2              0.000033 an 1.15 PopUp.-SEP1-			<Nop>
    2              0.000021 vnoremenu 1.20 PopUp.Cu&t		"+x
    2              0.000020 vnoremenu 1.30 PopUp.&Copy		"+y
    2              0.000017 cnoremenu 1.30 PopUp.&Copy		<C-Y>
    2              0.000014 nnoremenu 1.40 PopUp.&Paste		"+gP
    2              0.000014 cnoremenu 1.40 PopUp.&Paste		<C-R>+
    2              0.000040 exe 'vnoremenu <script> 1.40 PopUp.&Paste	' . paste#paste_cmd['v']
    2              0.000028 exe 'inoremenu <script> 1.40 PopUp.&Paste	' . paste#paste_cmd['i']
    2              0.000018 vnoremenu 1.50 PopUp.&Delete		x
    2              0.000031 an 1.55 PopUp.-SEP2-			<Nop>
    2              0.000020 vnoremenu 1.60 PopUp.Select\ Blockwise	<C-V>
                            
    2              0.000015 nnoremenu 1.70 PopUp.Select\ &Word	vaw
    2              0.000016 onoremenu 1.70 PopUp.Select\ &Word	aw
    2              0.000018 vnoremenu 1.70 PopUp.Select\ &Word	<C-C>vaw
    2              0.000039 inoremenu 1.70 PopUp.Select\ &Word	<C-O>vaw
    2              0.000051 cnoremenu 1.70 PopUp.Select\ &Word	<C-C>vaw
                            
    2              0.000131 nnoremenu 1.73 PopUp.Select\ &Sentence	vas
    2              0.000026 onoremenu 1.73 PopUp.Select\ &Sentence	as
    2              0.000028 vnoremenu 1.73 PopUp.Select\ &Sentence	<C-C>vas
    2              0.000032 inoremenu 1.73 PopUp.Select\ &Sentence	<C-O>vas
    2              0.000029 cnoremenu 1.73 PopUp.Select\ &Sentence	<C-C>vas
                            
    2              0.000016 nnoremenu 1.77 PopUp.Select\ Pa&ragraph	vap
    2              0.000013 onoremenu 1.77 PopUp.Select\ Pa&ragraph	ap
    2              0.000053 vnoremenu 1.77 PopUp.Select\ Pa&ragraph	<C-C>vap
    2              0.000019 inoremenu 1.77 PopUp.Select\ Pa&ragraph	<C-O>vap
    2              0.000013 cnoremenu 1.77 PopUp.Select\ Pa&ragraph	<C-C>vap
                            
    2              0.000029 nnoremenu 1.80 PopUp.Select\ &Line	V
    2              0.000013 onoremenu 1.80 PopUp.Select\ &Line	<C-C>V
    2              0.000016 vnoremenu 1.80 PopUp.Select\ &Line	<C-C>V
    2              0.000029 inoremenu 1.80 PopUp.Select\ &Line	<C-O>V
    2              0.000026 cnoremenu 1.80 PopUp.Select\ &Line	<C-C>V
                            
    2              0.000014 nnoremenu 1.90 PopUp.Select\ &Block	<C-V>
    2              0.000019 onoremenu 1.90 PopUp.Select\ &Block	<C-C><C-V>
    2              0.000032 vnoremenu 1.90 PopUp.Select\ &Block	<C-C><C-V>
    2              0.000031 inoremenu 1.90 PopUp.Select\ &Block	<C-O><C-V>
    2              0.000019 cnoremenu 1.90 PopUp.Select\ &Block	<C-C><C-V>
                            
    2              0.000054 noremenu  <script> <silent> 1.100 PopUp.Select\ &All	:<C-U>call <SID>SelectAll()<CR>
    2              0.000036 inoremenu <script> <silent> 1.100 PopUp.Select\ &All	<C-O>:call <SID>SelectAll()<CR>
    2              0.000023 cnoremenu <script> <silent> 1.100 PopUp.Select\ &All	<C-U>call <SID>SelectAll()<CR>
                            
    2              0.000017 if has("spell")
                              " Spell suggestions in the popup menu.  Note that this will slow down the
                              " appearance of the menu!
    2              0.000005   func! <SID>SpellPopup()
                                if exists("s:changeitem") && s:changeitem != ''
                                  call <SID>SpellDel()
                                endif
                            
                                " Return quickly if spell checking is not enabled.
                                if !&spell || &spelllang == ''
                                  return
                                endif
                            
                                let curcol = col('.')
                                let [w, a] = spellbadword()
                                if col('.') > curcol		" don't use word after the cursor
                                  let w = ''
                                endif
                                if w != ''
                                  if a == 'caps'
                            	let s:suglist = [substitute(w, '.*', '\u&', '')]
                                  else
                            	let s:suglist = spellsuggest(w, 10)
                                  endif
                                  if len(s:suglist) > 0
                            	let s:changeitem = 'change\ "' . escape(w, ' .'). '"\ to'
                            	let s:fromword = w
                            	let pri = 1
                            	" set 'cpo' to include the <CR>
                            	let cpo_save = &cpo
                            	set cpo&vim
                            	for sug in s:suglist
                            	  exe 'anoremenu 1.5.' . pri . ' PopUp.' . s:changeitem . '.' . escape(sug, ' .')
                            		\ . ' :call <SID>SpellReplace(' . pri . ')<CR>'
                            	  let pri += 1
                            	endfor
                            
                            	let s:additem = 'add\ "' . escape(w, ' .') . '"\ to\ word\ list'
                            	exe 'anoremenu 1.6 PopUp.' . s:additem . ' :spellgood ' . w . '<CR>'
                            
                            	let s:ignoreitem = 'ignore\ "' . escape(w, ' .') . '"'
                            	exe 'anoremenu 1.7 PopUp.' . s:ignoreitem . ' :spellgood! ' . w . '<CR>'
                            
                            	anoremenu 1.8 PopUp.-SpellSep- :
                            	let &cpo = cpo_save
                                  endif
                                endif
                                call cursor(0, curcol)	" put the cursor back where it was
                              endfunc
                            
    2              0.000005   func! <SID>SpellReplace(n)
                                let l = getline('.')
                                " Move the cursor to the start of the word.
                                call spellbadword()
                                call setline('.', strpart(l, 0, col('.') - 1) . s:suglist[a:n - 1]
                            	  \ . strpart(l, col('.') + len(s:fromword) - 1))
                              endfunc
                            
    2              0.000004   func! <SID>SpellDel()
                                exe "aunmenu PopUp." . s:changeitem
                                exe "aunmenu PopUp." . s:additem
                                exe "aunmenu PopUp." . s:ignoreitem
                                aunmenu PopUp.-SpellSep-
                                let s:changeitem = ''
                              endfun
                            
    2              0.000004   augroup SpellPopupMenu
    2              0.000104     au! MenuPopup * call <SID>SpellPopup()
    2              0.000002   augroup END
    2              0.000002 endif
                            
                            " The GUI toolbar (for MS-Windows and GTK)
    2              0.000008 if has("toolbar")
    2              0.000018   an 1.10 ToolBar.Open			:browse confirm e<CR>
    2              0.000024   an <silent> 1.20 ToolBar.Save		:if expand("%") == ""<Bar>browse confirm w<Bar>else<Bar>confirm w<Bar>endif<CR>
    2              0.000012   an 1.30 ToolBar.SaveAll		:browse confirm wa<CR>
                            
    2              0.000006   if has("printer")
    2              0.000011     an 1.40   ToolBar.Print		:hardcopy<CR>
    2              0.000004     vunmenu   ToolBar.Print
    2              0.000008     vnoremenu ToolBar.Print		:hardcopy<CR>
    2              0.000003   elseif has("unix")
                                an 1.40   ToolBar.Print		:w !lpr<CR>
                                vunmenu   ToolBar.Print
                                vnoremenu ToolBar.Print		:w !lpr<CR>
                              endif
                            
    2              0.000008   an 1.45 ToolBar.-sep1-		<Nop>
    2              0.000008   an 1.50 ToolBar.Undo			u
    2              0.000008   an 1.60 ToolBar.Redo			<C-R>
                            
    2              0.000007   an 1.65 ToolBar.-sep2-		<Nop>
    2              0.000008   vnoremenu 1.70 ToolBar.Cut		"+x
    2              0.000007   vnoremenu 1.80 ToolBar.Copy		"+y
    2              0.000008   cnoremenu 1.80 ToolBar.Copy		<C-Y>
    2              0.000008   nnoremenu 1.90 ToolBar.Paste		"+gP
    2              0.000007   cnoremenu	 ToolBar.Paste		<C-R>+
    2              0.000037   exe 'vnoremenu <script>	 ToolBar.Paste	' . paste#paste_cmd['v']
    2              0.000019   exe 'inoremenu <script>	 ToolBar.Paste	' . paste#paste_cmd['i']
                            
    2              0.000011   if !has("gui_athena") && !has("gui_macvim")
                                an 1.95   ToolBar.-sep3-		<Nop>
                                an 1.100  ToolBar.Replace		:promptrepl<CR>
                                vunmenu   ToolBar.Replace
                                vnoremenu ToolBar.Replace		y:promptrepl <C-R>=<SID>FixFText()<CR><CR>
                                an 1.110  ToolBar.FindNext		n
                                an 1.120  ToolBar.FindPrev		N
                              endif
                            
    2              0.000005   if !has("gui_macvim")
                                an 1.215 ToolBar.-sep5-		<Nop>
                              endif
    2              0.000014   an <silent> 1.220 ToolBar.LoadSesn	:call <SID>LoadVimSesn()<CR>
    2              0.000016   an <silent> 1.230 ToolBar.SaveSesn	:call <SID>SaveVimSesn()<CR>
    2              0.000012   an 1.240 ToolBar.RunScript		:browse so<CR>
                            
    2              0.000006   if !has("gui_macvim")
                                an 1.245 ToolBar.-sep6-		<Nop>
                              endif
    2              0.000009   an 1.250 ToolBar.Make			:make<CR>
    2              0.000005   if !has("gui_macvim")
                                an 1.270 ToolBar.RunCtags		:exe "!" . g:ctags_command<CR>
                                an 1.280 ToolBar.TagJump		g<C-]>
                              endif
                            
    2              0.000007   an 1.295 ToolBar.-sep7-		<Nop>
    2              0.000010   an 1.300 ToolBar.Help			:help<CR>
    2              0.000004   if !has("gui_macvim")
                                an <silent> 1.310 ToolBar.FindHelp	:call <SID>Helpfind()<CR>
                              endif
                            
                            " Only set the tooltips here if not done in a language menu file
    2              0.000007 if exists("*Do_toolbar_tmenu")
                              call Do_toolbar_tmenu()
                            else
    2              0.000007   let did_toolbar_tmenu = 1
    2              0.000007   tmenu ToolBar.Open		Open file
    2              0.000004   tmenu ToolBar.Save		Save current file
    2              0.000004   tmenu ToolBar.SaveAll		Save all files
    2              0.000004   tmenu ToolBar.Print		Print
    2              0.000006   tmenu ToolBar.Undo		Undo
    2              0.000004   tmenu ToolBar.Redo		Redo
    2              0.000005   tmenu ToolBar.Cut		Cut to clipboard
    2              0.000005   tmenu ToolBar.Copy		Copy to clipboard
    2              0.000006   tmenu ToolBar.Paste		Paste from Clipboard
    2              0.000007   if !has("gui_athena")
    2              0.000008     tmenu ToolBar.Replace	Find / Replace...
    2              0.000007     tmenu ToolBar.FindNext	Find Next
    2              0.000007     tmenu ToolBar.FindPrev	Find Previous
    2              0.000002   endif
    2              0.000006   tmenu ToolBar.LoadSesn	Choose a session to load
    2              0.000006   tmenu ToolBar.SaveSesn	Save current session
    2              0.000006   tmenu ToolBar.RunScript	Choose a Vim Script to run
    2              0.000006   tmenu ToolBar.Make		Make current project (:make)
    2              0.000009   tmenu ToolBar.RunCtags	Build tags in current directory tree (!ctags -R .)
    2              0.000006   tmenu ToolBar.TagJump		Jump to tag under cursor
    2              0.000006   tmenu ToolBar.Help		Vim Help
    2              0.000008   tmenu ToolBar.FindHelp	Search Vim Help
    2              0.000001 endif
                            
                            " Select a session to load; default to current session name if present
    2              0.000005 fun! s:LoadVimSesn()
                              if strlen(v:this_session) > 0
                                let name = s:FnameEscape(v:this_session)
                              else
                                let name = "Session.vim"
                              endif
                              execute "browse so " . name
                            endfun
                            
                            " Select a session to save; default to current session name if present
    2              0.000004 fun! s:SaveVimSesn()
                              if strlen(v:this_session) == 0
                                let v:this_session = "Session.vim"
                              endif
                              execute "browse mksession! " . s:FnameEscape(v:this_session)
                            endfun
                            
    2              0.000002 endif
                            
    2              0.000003 endif " !exists("did_install_default_menus")
                            
                            " Define these items always, so that syntax can be switched on when it wasn't.
                            " But skip them when the Syntax menu was disabled by the user.
    2              0.000006 if !exists("did_install_syntax_menu")
    2              0.000015   an 50.212 &Syntax.&Manual		:syn manual<CR>
    2              0.000011   an 50.214 &Syntax.A&utomatic		:syn on<CR>
    2              0.000017   an <silent> 50.216 &Syntax.on/off\ for\ &This\ file :call <SID>SynOnOff()<CR>
    2              0.000007   if !exists("*s:SynOnOff")
    1              0.000001     fun s:SynOnOff()
                                  if has("syntax_items")
                            	syn clear
                                  else
                            	if !exists("g:syntax_on")
                            	  syn manual
                            	endif
                            	set syn=ON
                                  endif
                                endfun
    1              0.000001   endif
    2              0.000002 endif
                            
                            
                            " Install the Syntax menu only when filetype.vim has been loaded or when
                            " manual syntax highlighting is enabled.
                            " Avoid installing the Syntax menu twice.
    2              0.000013 if (exists("did_load_filetypes") || exists("syntax_on"))
                            	\ && !exists("did_install_syntax_menu")
    2              0.000006   let did_install_syntax_menu = 1
                            
                            " Skip setting up the individual syntax selection menus unless
                            " do_syntax_sel_menu is defined (it takes quite a bit of time).
    2              0.000005 if exists("do_syntax_sel_menu")
                              runtime! synmenu.vim
                            else
    2              0.000029   an 50.10 &Syntax.&Show\ filetypes\ in\ menu	:let do_syntax_sel_menu = 1<Bar>runtime! synmenu.vim<Bar>aunmenu &Syntax.&Show\ filetypes\ in\ menu<CR>
    2              0.000008   an 50.195 &Syntax.-SEP1-		<Nop>
    2              0.000001 endif
                            
    2              0.000012 an 50.210 &Syntax.&Off			:syn off<CR>
    2              0.000007 an 50.700 &Syntax.-SEP3-		<Nop>
    2              0.000017 an 50.710 &Syntax.Co&lor\ test		:sp $VIMRUNTIME/syntax/colortest.vim<Bar>so %<CR>
    2              0.000036 an 50.720 &Syntax.&Highlight\ test	:runtime syntax/hitest.vim<CR>
    2              0.000022 an 50.730 &Syntax.&Convert\ to\ HTML	:runtime syntax/2html.vim<CR>
                            
    2              0.000003 endif " !exists("did_install_syntax_menu")
                            
                            " Restore the previous value of 'cpoptions'.
    2              0.000022 let &cpo = s:cpo_save
    2              0.000005 unlet s:cpo_save
                            
                            
    2              0.000023 if has("gui_macvim")
                              "
                              " Set up menu key equivalents (these should always have the 'D' modifier
                              " set), action bindings, and alternate items.
                              "
                              " Note: menu items which should execute an action are bound to <Nop>; the
                              " action message is specified here via the :macmenu command.
                              "
    2              0.000047   macm File.New\ Window				key=<D-n> action=newWindow:
    2              0.000006   macm File.New\ Tab				key=<D-t>
    2              0.000009   macm File.Open\.\.\.				key=<D-o> action=fileOpen:
    2              0.000008   macm File.Open\ Tab\.\.\.<Tab>:tabnew		key=<D-T>
    2              0.000008   macm File.Open\ Recent			action=recentFilesDummy:
    2              0.000006   macm File.Close\ Window<Tab>:qa		key=<D-W>
    2              0.000007   macm File.Close				key=<D-w> action=performClose:
    2              0.000004   macm File.Save<Tab>:w				key=<D-s>
    2              0.000006   macm File.Save\ All				key=<D-M-s> alt=YES
    2              0.000006   macm File.Save\ As\.\.\.<Tab>:sav		key=<D-S>
    2              0.000004   macm File.Print				key=<D-p>
                            
    2              0.000010   macm Edit.Undo<Tab>u				key=<D-z> action=undo:
    2              0.000006   macm Edit.Redo<Tab>^R				key=<D-Z> action=redo:
    2              0.000018   macm Edit.Cut<Tab>"+x				key=<D-x> action=cut:
    2              0.000005   macm Edit.Copy<Tab>"+y			key=<D-c> action=copy:
    2              0.000006   macm Edit.Paste<Tab>"+gP			key=<D-v> action=paste:
    2              0.000009   macm Edit.Select\ All<Tab>ggVG		key=<D-a> action=selectAll:
    2              0.000005   macm Edit.Find.Find\.\.\.			key=<D-f>
    2              0.000007   macm Edit.Find.Find\ Next			key=<D-g> action=findNext:
    2              0.000008   macm Edit.Find.Find\ Previous			key=<D-G> action=findPrevious:
    2              0.000006   macm Edit.Find.Use\ Selection\ for\ Find	key=<D-e>
    2              0.000009   macm Edit.Font.Show\ Fonts			action=orderFrontFontPanel:
    2              0.000007   macm Edit.Font.Bigger				key=<D-=> action=fontSizeUp:
    2              0.000007   macm Edit.Font.Smaller			key=<D--> action=fontSizeDown:
    2              0.000010   macm Edit.Special\ Characters\.\.\.		key=<D-M-t> action=orderFrontCharacterPalette:
                            
    2              0.000007   macm Tools.Spelling.To\ Next\ error<Tab>]s	key=<D-;>
    2              0.000007   macm Tools.Spelling.Suggest\ Corrections<Tab>z=   key=<D-:>
    2              0.000005   macm Tools.Make<Tab>:make			key=<D-b>
    2              0.000005   macm Tools.List\ Errors<Tab>:cl		key=<D-l>
    2              0.000006   macm Tools.Next\ Error<Tab>:cn		key=<D-C-Right>
    2              0.000006   macm Tools.Previous\ Error<Tab>:cp		key=<D-C-Left>
    2              0.000006   macm Tools.Older\ List<Tab>:cold		key=<D-C-Up>
    2              0.000006   macm Tools.Newer\ List<Tab>:cnew		key=<D-C-Down>
                            
    2              0.000007   macm Window.Minimize		key=<D-m>	action=performMiniaturize:
    2              0.000009   macm Window.Minimize\ All	key=<D-M-m>	action=miniaturizeAll:	alt=YES
    2              0.000008   macm Window.Zoom		key=<D-C-z>	action=performZoom:
    2              0.000008   macm Window.Zoom\ All		key=<D-M-C-z>	action=zoomAll:		alt=YES
    2              0.000006   macm Window.Toggle\ Full\ Screen\ Mode	key=<D-C-f>
    2              0.000005   macm Window.Select\ Next\ Tab			key=<D-}>
    2              0.000005   macm Window.Select\ Previous\ Tab		key=<D-{>
    2              0.000008   macm Window.Bring\ All\ To\ Front		action=arrangeInFront:
                            
    2              0.000005   macm Help.MacVim\ Help			key=<D-?>
    2              0.000006   macm Help.MacVim\ Website			action=openWebsite:
    2              0.000002 endif
                            
                            " vim: set sw=2 :

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/autoload/paste.vim
Sourced 1 time
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
                            " Vim support file to help with paste mappings and menus
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2006 Jun 23
                            
                            " Define the string to use for items that are present both in Edit, Popup and
                            " Toolbar menu.  Also used in mswin.vim and macmap.vim.
                            
                            " Pasting blockwise and linewise selections is not possible in Insert and
                            " Visual mode without the +virtualedit feature.  They are pasted as if they
                            " were characterwise instead.  Add to that some tricks to leave the cursor in
                            " the right position, also for "gi".
    1              0.000014 if has("virtualedit")
    1              0.000010   let paste#paste_cmd = {'n': ":call paste#Paste()<CR>"}
    1              0.000010   let paste#paste_cmd['v'] = '"-c<Esc>' . paste#paste_cmd['n']
    1              0.000007   let paste#paste_cmd['i'] = 'x<BS><Esc>' . paste#paste_cmd['n'] . 'gi'
                            
    1              0.000006   func! paste#Paste()
                                let ove = &ve
                                set ve=all
                                normal! `^
                                if @+ != ''
                                  normal! "+gP
                                endif
                                let c = col(".")
                                normal! i
                                if col(".") < c	" compensate for i<ESC> moving the cursor left
                                  normal! l
                                endif
                                let &ve = ove
                              endfunc
    1              0.000003 else
                              let paste#paste_cmd = {'n': "\"=@+.'xy'<CR>gPFx\"_2x"}
                              let paste#paste_cmd['v'] = '"-c<Esc>gix<Esc>' . paste#paste_cmd['n'] . '"_x'
                              let paste#paste_cmd['i'] = 'x<Esc>' . paste#paste_cmd['n'] . '"_s'
                            endif

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/ftplugin.vim
Sourced 1 time
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
                            " Vim support file to switch on loading plugins for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2006 Apr 30
                            
    1              0.000013 if exists("did_load_ftplugin")
                              finish
                            endif
    1              0.000006 let did_load_ftplugin = 1
                            
    1              0.000004 augroup filetypeplugin
    1              0.000014   au FileType * call s:LoadFTPlugin()
                            
    1              0.000008   func! s:LoadFTPlugin()
                                if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
                                endif
                            
                                let s = expand("<amatch>")
                                if s != ""
                                  if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
                                  for name in split(s, '\.')
                            	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
                                  endfor
                                endif
                              endfunc
    1              0.000007 augroup END

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/indent.vim
Sourced 1 time
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
                            " Vim support file to switch on loading indent files for file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2008 Feb 22
                            
    1              0.000012 if exists("did_indent_on")
                              finish
                            endif
    1              0.000005 let did_indent_on = 1
                            
    1              0.000004 augroup filetypeindent
    1              0.000012   au FileType * call s:LoadIndent()
    1              0.000007   func! s:LoadIndent()
                                if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
                                let s = expand("<amatch>")
                                if s != ""
                                  if exists("b:did_indent")
                            	unlet b:did_indent
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
                                  for name in split(s, '\.')
                            	exe 'runtime! indent/' . name . '.vim'
                                  endfor
                                endif
                              endfunc
    1              0.000005 augroup END

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/delmenu.vim
Sourced 1 time
Total time:   0.000740
 Self time:   0.000740

count  total (s)   self (s)
                            " This Vim script deletes all the menus, so that they can be redefined.
                            " Warning: This also deletes all menus defined by the user!
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 May 27
                            
    1              0.000647 aunmenu *
                            
    1              0.000007 silent! unlet did_install_default_menus
    1              0.000003 silent! unlet did_install_syntax_menu
    1              0.000011 if exists("did_menu_trans")
                              menutrans clear
                              unlet did_menu_trans
                            endif
                            
    1              0.000013 silent! unlet find_help_dialog
                            
    1              0.000005 silent! unlet menutrans_help_dialog
    1              0.000004 silent! unlet menutrans_path_dialog
    1              0.000004 silent! unlet menutrans_tags_dialog
    1              0.000005 silent! unlet menutrans_textwidth_dialog
    1              0.000004 silent! unlet menutrans_fileformat_dialog
    1              0.000004 silent! unlet menutrans_no_file
                            
                            " vim: set sw=2 :

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/lang/menu_en_gb.latin1.vim
Sourced 2 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
                            " Menu Translations:	UK English
                            " Maintainer:		Mike Williams <mrw@eandem.co.uk>
                            " Last Change:		2003 Feb 10
                            
                            " Quit when menu translations have already been done.
    2              0.000032 if exists("did_menu_trans")
    1              0.000003   finish
                            endif
    1              0.000008 let did_menu_trans = 1
                            
                            " Note: there is no "scriptencoding" command here, all encodings should be
                            " able to handle ascii characters without conversion.
                            
                            " Convert from American to UK spellings.
    1              0.000009 menutrans C&olor\ Scheme			C&olour\ Scheme
    1              0.000010 menutrans Co&lor\ test				Co&lour\ test

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/lang/menu_en_gb.utf-8.vim
Sourced 1 time
Total time:   0.000151
 Self time:   0.000120

count  total (s)   self (s)
                            " Menu Translations:	UK English
                            
    1              0.000094 source <sfile>:p:h/menu_en_gb.latin1.vim

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/syntax/syntax.vim
Sourced 1 time
Total time:   0.001688
 Self time:   0.000437

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 04
                            
                            " This file is used for ":syntax on".
                            " It installs the autocommands and starts highlighting for all buffers.
                            
    1              0.000012 if !has("syntax")
                              finish
                            endif
                            
                            " If Syntax highlighting appears to be on already, turn it off first, so that
                            " any leftovers are cleared.
    1              0.000005 if exists("syntax_on") || exists("syntax_manual")
                              so <sfile>:p:h/nosyntax.vim
                            endif
                            
                            " Load the Syntax autocommands and set the default methods for highlighting.
    1              0.000081 runtime syntax/synload.vim
                            
                            " Load the FileType autocommands if not done yet.
    1              0.000006 if exists("did_load_filetypes")
    1              0.000003   let s:did_ft = 1
    1              0.000001 else
                              filetype on
                              let s:did_ft = 0
                            endif
                            
                            " Set up the connection between FileType and Syntax autocommands.
                            " This makes the syntax automatically set when the file type is detected.
    1              0.000002 augroup syntaxset
    1              0.000009   au! FileType *	exe "set syntax=" . expand("<amatch>")
    1              0.000002 augroup END
                            
                            
                            " Execute the syntax autocommands for the each buffer.
                            " If the filetype wasn't detected yet, do that now.
                            " Always do the syntaxset autocommands, for buffers where the 'filetype'
                            " already was set manually (e.g., help buffers).
    1              0.000009 doautoall syntaxset FileType
    1              0.000002 if !s:did_ft
                              doautoall filetypedetect BufRead
                            endif

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/syntax/synload.vim
Sourced 1 time
Total time:   0.001177
 Self time:   0.000631

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2012 Sep 25
                            
                            " This file sets up for syntax highlighting.
                            " It is loaded from "syntax.vim" and "manual.vim".
                            " 1. Set the default highlight groups.
                            " 2. Install Syntax autocommands for all the available syntax files.
                            
    1              0.000023 if !has("syntax")
                              finish
                            endif
                            
                            " let others know that syntax has been switched on
    1              0.000006 let syntax_on = 1
                            
                            " Set the default highlighting colors.  Use a color scheme if specified.
    1              0.000004 if exists("colors_name")
                              exe "colors " . colors_name
                            else
    1              0.000079   runtime! syntax/syncolor.vim
    1              0.000003 endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000012 let s:cpo_save = &cpo
    1              0.000009 set cpo&vim
                            
                            " First remove all old syntax autocommands.
    1              0.000007 au! Syntax
                            
    1              0.000010 au Syntax *		call s:SynSet()
                            
    1              0.000008 fun! s:SynSet()
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
                              syn clear
                              if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
                              let s = expand("<amatch>")
                              if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
                              if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
                                for name in split(s, '\.')
                                  exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
                                endfor
                              endif
                            endfun
                            
                            
                            " Handle adding doxygen to other languages (C, C++, C#, IDL)
    1              0.000026 au Syntax c,cpp,cs,idl,php
                            	\ if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)
                            	\	|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)
                            	\   | runtime! syntax/doxygen.vim
                            	\ | endif
                            
                            
                            " Source the user-specified syntax highlighting file
    1              0.000008 if exists("mysyntaxfile") && filereadable(expand(mysyntaxfile))
                              execute "source " . mysyntaxfile
                            endif
                            
                            " Restore 'cpoptions'
    1              0.000008 let &cpo = s:cpo_save
    1              0.000006 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/syntax/syncolor.vim
Sourced 10 times
Total time:   0.002844
 Self time:   0.002844

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 12
                            
                            " This file sets up the default methods for highlighting.
                            " It is loaded from "synload.vim" and from Vim for ":syntax reset".
                            " Also used from init_highlight().
                            
   10              0.000085 if !exists("syntax_cmd") || syntax_cmd == "on"
                              " ":syntax on" works like in Vim 5.7: set colors but keep links
    5              0.000039   command -nargs=* SynColor hi <args>
    5              0.000025   command -nargs=* SynLink hi link <args>
    5              0.000008 else
    5              0.000010   if syntax_cmd == "enable"
                                " ":syntax enable" keeps any existing colors
    1              0.000009     command -nargs=* SynColor hi def <args>
    1              0.000016     command -nargs=* SynLink hi def link <args>
    1              0.000002   elseif syntax_cmd == "reset"
                                " ":syntax reset" resets all colors to the default
    4              0.000020     command -nargs=* SynColor hi <args>
    4              0.000016     command -nargs=* SynLink hi! link <args>
    4              0.000004   else
                                " User defined syncolor file has already set the colors.
                                finish
                              endif
    5              0.000005 endif
                            
                            " Many terminals can only use six different colors (plus black and white).
                            " Therefore the number of colors used is kept low. It doesn't look nice with
                            " too many colors anyway.
                            " Careful with "cterm=bold", it changes the color to bright for some terminals.
                            " There are two sets of defaults: for a dark and a light background.
   10              0.000038 if &background == "dark"
   10              0.000289   SynColor Comment	term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
   10              0.000142   SynColor Constant	term=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
   10              0.000102   SynColor Special	term=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
   10              0.000107   SynColor Identifier	term=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
   10              0.000100   SynColor Statement	term=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
   10              0.000101   SynColor PreProc	term=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
   10              0.000097   SynColor Type		term=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
   10              0.000094   SynColor Underlined	term=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
   10              0.000072   SynColor Ignore	term=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
   10              0.000010 else
                              SynColor Comment	term=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
                              SynColor Constant	term=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
                              SynColor Special	term=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
                              SynColor Identifier	term=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
                              SynColor Statement	term=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
                              SynColor PreProc	term=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
                              SynColor Type		term=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
                              SynColor Underlined	term=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
                              SynColor Ignore	term=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
                            endif
   10              0.000132 SynColor Error		term=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
   10              0.000118 SynColor Todo		term=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
                            
                            " Common groups that link to default highlighting.
                            " You can specify other highlighting easily.
   10              0.000046 SynLink String		Constant
   10              0.000038 SynLink Character	Constant
   10              0.000028 SynLink Number		Constant
   10              0.000031 SynLink Boolean		Constant
   10              0.000032 SynLink Float		Number
   10              0.000031 SynLink Function	Identifier
   10              0.000032 SynLink Conditional	Statement
   10              0.000032 SynLink Repeat		Statement
   10              0.000031 SynLink Label		Statement
   10              0.000030 SynLink Operator	Statement
   10              0.000032 SynLink Keyword		Statement
   10              0.000033 SynLink Exception	Statement
   10              0.000030 SynLink Include		PreProc
   10              0.000030 SynLink Define		PreProc
   10              0.000029 SynLink Macro		PreProc
   10              0.000031 SynLink PreCondit	PreProc
   10              0.000031 SynLink StorageClass	Type
   10              0.000028 SynLink Structure	Type
   10              0.000029 SynLink Typedef		Type
   10              0.000031 SynLink Tag		Special
   10              0.000030 SynLink SpecialChar	Special
   10              0.000026 SynLink Delimiter	Special
   10              0.000033 SynLink SpecialComment	Special
   10              0.000031 SynLink Debug		Special
                            
   10              0.000019 delcommand SynColor
   10              0.000036 delcommand SynLink

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/colors/desert.vim
Sourced 3 times
Total time:   0.017530
 Self time:   0.015626

count  total (s)   self (s)
                            " Vim color file
                            " Maintainer:	Hans Fugal <hans@fugal.net>
                            " Last Change:	$Date: 2004/06/13 19:30:30 $
                            " Last Change:	$Date: 2004/06/13 19:30:30 $
                            " URL:		http://hans.fugal.net/vim/colors/desert.vim
                            " Version:	$Id: desert.vim,v 1.1 2004/06/13 19:30:30 vimboss Exp $
                            
                            " cool help screens
                            " :he group-name
                            " :he highlight-groups
                            " :he cterm-colors
                            
    3              0.000379 set background=dark
    3              0.000012 if version > 580
                                " no guarantees for version 5.8 and below, but this makes it stop
                                " complaining
    3              0.013378     hi clear
    3              0.000014     if exists("syntax_on")
    3              0.000479 	syntax reset
    3              0.000004     endif
    3              0.000003 endif
    3              0.000013 let g:colors_name="desert"
                            
    3              0.000033 hi Normal	guifg=White guibg=grey20
                            
                            " highlight groups
    3              0.000025 hi Cursor	guibg=khaki guifg=slategrey
                            "hi CursorIM
                            "hi Directory
                            "hi DiffAdd
                            "hi DiffChange
                            "hi DiffDelete
                            "hi DiffText
                            "hi ErrorMsg
    3              0.000027 hi VertSplit	guibg=#c2bfa5 guifg=grey50 gui=none
    3              0.000025 hi Folded	guibg=grey30 guifg=gold
    3              0.000022 hi FoldColumn	guibg=grey30 guifg=tan
    3              0.000023 hi IncSearch	guifg=slategrey guibg=khaki
                            "hi LineNr
    3              0.000014 hi ModeMsg	guifg=goldenrod
    3              0.000013 hi MoreMsg	guifg=SeaGreen
    3              0.000027 hi NonText	guifg=LightBlue guibg=grey30
    3              0.000015 hi Question	guifg=springgreen
    3              0.000021 hi Search	guibg=peru guifg=wheat
    3              0.000020 hi SpecialKey	guifg=yellowgreen
    3              0.000025 hi StatusLine	guibg=#c2bfa5 guifg=black gui=none
    3              0.000022 hi StatusLineNC	guibg=#c2bfa5 guifg=grey50 gui=none
    3              0.000017 hi Title	guifg=indianred
    3              0.000020 hi Visual	gui=none guifg=khaki guibg=olivedrab
                            "hi VisualNOS
    3              0.000012 hi WarningMsg	guifg=salmon
                            "hi WildMenu
                            "hi Menu
                            "hi Scrollbar
                            "hi Tooltip
                            
                            " syntax highlighting groups
    3              0.000013 hi Comment	guifg=SkyBlue
    3              0.000015 hi Constant	guifg=#ffa0a0
    3              0.000014 hi Identifier	guifg=palegreen
    3              0.000014 hi Statement	guifg=khaki
    3              0.000014 hi PreProc	guifg=indianred
    3              0.000024 hi Type		guifg=darkkhaki
    3              0.000016 hi Special	guifg=navajowhite
                            "hi Underlined
    3              0.000012 hi Ignore	guifg=grey40
                            "hi Error
    3              0.000020 hi Todo		guifg=orangered guibg=yellow2
                            
                            " color terminal definitions
    3              0.000010 hi SpecialKey	ctermfg=darkgreen
    3              0.000010 hi NonText	cterm=bold ctermfg=darkblue
    3              0.000006 hi Directory	ctermfg=darkcyan
    3              0.000018 hi ErrorMsg	cterm=bold ctermfg=7 ctermbg=1
    3              0.000011 hi IncSearch	cterm=NONE ctermfg=yellow ctermbg=green
    3              0.000010 hi Search	cterm=NONE ctermfg=grey ctermbg=blue
    3              0.000008 hi MoreMsg	ctermfg=darkgreen
    3              0.000008 hi ModeMsg	cterm=NONE ctermfg=brown
    3              0.000007 hi LineNr	ctermfg=3
    3              0.000006 hi Question	ctermfg=green
    3              0.000008 hi StatusLine	cterm=bold,reverse
    3              0.000008 hi StatusLineNC cterm=reverse
    3              0.000006 hi VertSplit	cterm=reverse
    3              0.000007 hi Title	ctermfg=5
    3              0.000006 hi Visual	cterm=reverse
    3              0.000007 hi VisualNOS	cterm=bold,underline
    3              0.000006 hi WarningMsg	ctermfg=1
    3              0.000009 hi WildMenu	ctermfg=0 ctermbg=3
    3              0.000009 hi Folded	ctermfg=darkgrey ctermbg=NONE
    3              0.000007 hi FoldColumn	ctermfg=darkgrey ctermbg=NONE
    3              0.000007 hi DiffAdd	ctermbg=4
    3              0.000006 hi DiffChange	ctermbg=5
    3              0.000010 hi DiffDelete	cterm=bold ctermfg=4 ctermbg=6
    3              0.000017 hi DiffText	cterm=bold ctermbg=1
    3              0.000006 hi Comment	ctermfg=darkcyan
    3              0.000006 hi Constant	ctermfg=brown
    3              0.000006 hi Special	ctermfg=5
    3              0.000006 hi Identifier	ctermfg=6
    3              0.000006 hi Statement	ctermfg=3
    3              0.000006 hi PreProc	ctermfg=5
    3              0.000006 hi Type		ctermfg=2
    3              0.000007 hi Underlined	cterm=underline ctermfg=5
    3              0.000007 hi Ignore	cterm=bold ctermfg=7
    3              0.000005 hi Ignore	ctermfg=darkgrey
    3              0.000006 hi Error	cterm=bold ctermfg=7 ctermbg=1
                            
                            
                            "vim: sw=4

SCRIPT  /Users/Vishal/.vim_runtime/vimrcs/filetypes.vim
Sourced 1 time
Total time:   0.000464
 Self time:   0.000464

count  total (s)   self (s)
                            """"""""""""""""""""""""""""""
                            " => Python section
                            """"""""""""""""""""""""""""""
    1              0.000012 let python_highlight_all = 1
    1              0.000017 au FileType python syn keyword pythonDecorator True None False self
                            
    1              0.000213 au BufNewFile,BufRead *.jinja set syntax=htmljinja
    1              0.000051 au BufNewFile,BufRead *.mako set ft=mako
                            
    1              0.000006 au FileType python map <buffer> F :set foldmethod=indent<cr>
                            
    1              0.000005 au FileType python inoremap <buffer> $r return 
    1              0.000005 au FileType python inoremap <buffer> $i import 
    1              0.000005 au FileType python inoremap <buffer> $p print 
    1              0.000006 au FileType python inoremap <buffer> $f #--- PH ----------------------------------------------<esc>FP2xi
    1              0.000005 au FileType python map <buffer> <leader>1 /class 
    1              0.000004 au FileType python map <buffer> <leader>2 /def 
    1              0.000005 au FileType python map <buffer> <leader>C ?class 
    1              0.000005 au FileType python map <buffer> <leader>D ?def 
                            
                            
                            """"""""""""""""""""""""""""""
                            " => JavaScript section
                            """""""""""""""""""""""""""""""
    1              0.000010 au FileType javascript call JavaScriptFold()
    1              0.000005 au FileType javascript setl fen
    1              0.000005 au FileType javascript setl nocindent
                            
    1              0.000005 au FileType javascript imap <c-t> $log();<esc>hi
    1              0.000005 au FileType javascript imap <c-a> alert();<esc>hi
                            
    1              0.000005 au FileType javascript inoremap <buffer> $r return 
    1              0.000006 au FileType javascript inoremap <buffer> $f //--- PH ----------------------------------------------<esc>FP2xi
                            
    1              0.000005 function! JavaScriptFold() 
                                setl foldmethod=syntax
                                setl foldlevelstart=1
                                syn region foldBraces start=/{/ end=/}/ transparent fold keepend extend
                            
                                function! FoldText()
                                    return substitute(getline(v:foldstart), '{.*', '{...}', '')
                                endfunction
                                setl foldtext=FoldText()
                            endfunction
                            
                            
                            """"""""""""""""""""""""""""""
                            " => CoffeeScript section
                            """""""""""""""""""""""""""""""
    1              0.000003 function! CoffeeScriptFold()
                                setl foldmethod=indent
                                setl foldlevelstart=1
                            endfunction
    1              0.000009 au FileType coffee call CoffeeScriptFold()
                            
    1              0.000014 au FileType gitcommit call setpos('.', [0, 1, 1, 0])

SCRIPT  /Users/Vishal/.vim_runtime/vimrcs/plugins_config.vim
Sourced 1 time
Total time:   0.155980
 Self time:   0.000978

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Important: 
                            "       This requries that you install https://github.com/amix/vimrc !
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
                            """"""""""""""""""""""""""""""
                            " => Load pathogen paths
                            """"""""""""""""""""""""""""""
    1              0.000248 call pathogen#infect('~/.vim_runtime/sources_forked/{}')
    1   0.049673   0.000011 call pathogen#infect('~/.vim_runtime/sources_non_forked/{}')
    1   0.072510   0.000018 call pathogen#helptags()
                            
                            """"""""""""""""""""""""""""""
                            " => bufExplorer plugin
                            """"""""""""""""""""""""""""""
    1              0.000006 let g:bufExplorerDefaultHelp=0
    1              0.000004 let g:bufExplorerShowRelativePath=1
    1              0.000003 let g:bufExplorerFindActive=1
    1              0.000003 let g:bufExplorerSortBy='name'
    1              0.000023 map <leader>o :BufExplorer<cr>
                            
                            
                            """"""""""""""""""""""""""""""
                            " => MRU plugin
                            """"""""""""""""""""""""""""""
    1              0.000003 let MRU_Max_Entries = 400
    1              0.000011 map <leader>f :MRU<CR>
                            
                            
                            """"""""""""""""""""""""""""""
                            " => YankRing
                            """"""""""""""""""""""""""""""
    1              0.000012 if has("win16") || has("win32")
                                " Don't do anything
                            else
    1              0.000004     let g:yankring_history_dir = '~/.vim_runtime/temp_dirs/'
    1              0.000002 endif
                            
                            
                            """"""""""""""""""""""""""""""
                            " => CTRL-P
                            """"""""""""""""""""""""""""""
    1              0.000004 let g:ctrlp_working_path_mode = 0
                            
    1              0.000002 let g:ctrlp_map = '<c-f>'
    1              0.000011 map <leader>j :CtrlP<cr>
    1              0.000008 map <c-b> :CtrlPBuffer<cr>
                            
    1              0.000004 let g:ctrlp_max_height = 20
    1              0.000005 let g:ctrlp_custom_ignore = 'node_modules\|^\.DS_Store\|^\.git\|^\.coffee|^\.cabal-sandbox|^\dist'
                            
                            
                            """"""""""""""""""""""""""""""
                            " => ZenCoding
                            """"""""""""""""""""""""""""""
                            " Enable all functions in all modes
    1              0.000002 let g:user_zen_mode='a'
                            
                            
                            """"""""""""""""""""""""""""""
                            " => snipMate (beside <TAB> support <CTRL-j>)
                            """"""""""""""""""""""""""""""
    1              0.000010 ino <c-j> <c-r>=snipMate#TriggerSnippet()<cr>
    1              0.000014 snor <c-j> <esc>i<right><c-r>=snipMate#TriggerSnippet()<cr>
                            
                            
                            """"""""""""""""""""""""""""""
                            " => Vim grep
                            """"""""""""""""""""""""""""""
    1              0.000003 let Grep_Skip_Dirs = 'RCS CVS SCCS .svn generated'
    1              0.000008 set grepprg=/bin/grep\ -nH
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Nerd Tree
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000003 let g:NERDTreeWinPos = "right"
    1              0.000004 let NERDTreeIgnore = ['\.pyc$']
    1              0.000003 let g:NERDTreeWinSize=35
    1              0.000011 map <leader>nn :NERDTreeToggle<cr>
    1              0.000011 map <leader>nb :NERDTreeFromBookmark 
    1              0.000010 map <leader>nf :NERDTreeFind<cr>
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => vim-multiple-cursors
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000004 let g:multi_cursor_next_key="\<C-s>"
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => surround.vim config
                            " Annotate strings with gettext http://amix.dk/blog/post/19678
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000008 vmap Si S(i_<esc>f)
    1              0.000015 au FileType mako vmap Si S"i${ _(<esc>2f"a) }<esc>
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => vim-airline config (force color)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000003 let g:airline_theme="luna"
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Vimroom
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000003 let g:goyo_width=100
    1              0.000002 let g:goyo_margin_top = 2
    1              0.000002 let g:goyo_margin_bottom = 2
    1              0.000010 nnoremap <silent> <leader>z :Goyo<cr>
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Syntastic (syntax checker)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000007 let g:syntastic_python_checkers=['pyflakes']

SCRIPT  /Users/Vishal/.vim_runtime/autoload/pathogen.vim
Sourced 1 time
Total time:   0.001212
 Self time:   0.001212

count  total (s)   self (s)
                            " pathogen.vim - path option manipulation
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            " Version:      2.3
                            
                            " Install in ~/.vim/autoload (or ~\vimfiles\autoload).
                            "
                            " For management of individually installed plugins in ~/.vim/bundle (or
                            " ~\vimfiles\bundle), adding `execute pathogen#infect()` to the top of your
                            " .vimrc is the only other setup necessary.
                            "
                            " The API is documented inline below.
                            
    1              0.000025 if exists("g:loaded_pathogen") || &cp
                              finish
                            endif
    1              0.000007 let g:loaded_pathogen = 1
                            
                            " Point of entry for basic default usage.  Give a relative path to invoke
                            " pathogen#interpose() (defaults to "bundle/{}"), or an absolute path to invoke
                            " pathogen#surround().  Curly braces are expanded with pathogen#expand():
                            " "bundle/{}" finds all subdirectories inside "bundle" inside all directories
                            " in the runtime path.
    1              0.000007 function! pathogen#infect(...) abort
                              for path in a:0 ? filter(reverse(copy(a:000)), 'type(v:val) == type("")') : ['bundle/{}']
                                if path =~# '^\%({\=[$~\\/]\|{\=\w:[\\/]\).*[{}*]'
                                  call pathogen#surround(path)
                                elseif path =~# '^\%([$~\\/]\|\w:[\\/]\)'
                                  call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
                                  call pathogen#surround(path . '/{}')
                                elseif path =~# '[{}*]'
                                  call pathogen#interpose(path)
                                else
                                  call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
                                  call pathogen#interpose(path . '/{}')
                                endif
                              endfor
                              call pathogen#cycle_filetype()
                              if pathogen#is_disabled($MYVIMRC)
                                return 'finish'
                              endif
                              return ''
                            endfunction
                            
                            " Split a path into a list.
    1              0.000004 function! pathogen#split(path) abort
                              if type(a:path) == type([]) | return a:path | endif
                              if empty(a:path) | return [] | endif
                              let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')
                              return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')
                            endfunction
                            
                            " Convert a list to a path.
    1              0.000004 function! pathogen#join(...) abort
                              if type(a:1) == type(1) && a:1
                                let i = 1
                                let space = ' '
                              else
                                let i = 0
                                let space = ''
                              endif
                              let path = ""
                              while i < a:0
                                if type(a:000[i]) == type([])
                                  let list = a:000[i]
                                  let j = 0
                                  while j < len(list)
                                    let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
                                    let path .= ',' . escaped
                                    let j += 1
                                  endwhile
                                else
                                  let path .= "," . a:000[i]
                                endif
                                let i += 1
                              endwhile
                              return substitute(path,'^,','','')
                            endfunction
                            
                            " Convert a list to a path with escaped spaces for 'path', 'tag', etc.
    1              0.000004 function! pathogen#legacyjoin(...) abort
                              return call('pathogen#join',[1] + a:000)
                            endfunction
                            
                            " Turn filetype detection off and back on again if it was already enabled.
    1              0.000003 function! pathogen#cycle_filetype() abort
                              if exists('g:did_load_filetypes')
                                filetype off
                                filetype on
                              endif
                            endfunction
                            
                            " Check if a bundle is disabled.  A bundle is considered disabled if its
                            " basename or full name is included in the list g:pathogen_disabled.
    1              0.000005 function! pathogen#is_disabled(path) abort
                              if a:path =~# '\~$'
                                return 1
                              endif
                              let sep = pathogen#slash()
                              let blacklist = map(
                                    \ get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) +
                                    \ pathogen#split($VIMBLACKLIST),
                                    \ 'substitute(v:val, "[\\/]$", "", "")')
                              return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1
                            endfunction "}}}1
                            
                            " Prepend the given directory to the runtime path and append its corresponding
                            " after directory.  Curly braces are expanded with pathogen#expand().
    1              0.000004 function! pathogen#surround(path) abort
                              let sep = pathogen#slash()
                              let rtp = pathogen#split(&rtp)
                              let path = fnamemodify(a:path, ':p:?[\\/]\=$??')
                              let before = filter(pathogen#expand(path), '!pathogen#is_disabled(v:val)')
                              let after = filter(reverse(pathogen#expand(path.sep.'after')), '!pathogen#is_disabled(v:val[0:-7])')
                              call filter(rtp, 'index(before + after, v:val) == -1')
                              let &rtp = pathogen#join(before, rtp, after)
                              return &rtp
                            endfunction
                            
                            " For each directory in the runtime path, add a second entry with the given
                            " argument appended.  Curly braces are expanded with pathogen#expand().
    1              0.000012 function! pathogen#interpose(name) abort
                              let sep = pathogen#slash()
                              let name = a:name
                              if has_key(s:done_bundles, name)
                                return ""
                              endif
                              let s:done_bundles[name] = 1
                              let list = []
                              for dir in pathogen#split(&rtp)
                                if dir =~# '\<after$'
                                  let list += reverse(filter(pathogen#expand(dir[0:-6].name.sep.'after'), '!pathogen#is_disabled(v:val[0:-7])')) + [dir]
                                else
                                  let list += [dir] + filter(pathogen#expand(dir.sep.name), '!pathogen#is_disabled(v:val)')
                                endif
                              endfor
                              let &rtp = pathogen#join(pathogen#uniq(list))
                              return 1
                            endfunction
                            
    1              0.000008 let s:done_bundles = {}
                            
                            " Invoke :helptags on all non-$VIM doc directories in runtimepath.
    1              0.000014 function! pathogen#helptags() abort
                              let sep = pathogen#slash()
                              for glob in pathogen#split(&rtp)
                                for dir in map(split(glob(glob), "\n"), 'v:val.sep."/doc/".sep')
                                  if (dir)[0 : strlen($VIMRUNTIME)] !=# $VIMRUNTIME.sep && filewritable(dir) == 2 && !empty(split(glob(dir.'*.txt'))) && (!filereadable(dir.'tags') || filewritable(dir.'tags'))
                                    silent! execute 'helptags' pathogen#fnameescape(dir)
                                  endif
                                endfor
                              endfor
                            endfunction
                            
    1              0.000011 command! -bar Helptags :call pathogen#helptags()
                            
                            " Execute the given command.  This is basically a backdoor for --remote-expr.
    1              0.000005 function! pathogen#execute(...) abort
                              for command in a:000
                                execute command
                              endfor
                              return ''
                            endfunction
                            
                            " Section: Unofficial
                            
    1              0.000005 function! pathogen#is_absolute(path) abort
                              return a:path =~# (has('win32') ? '^\%([\\/]\|\w:\)[\\/]\|^[~$]' : '^[/~$]')
                            endfunction
                            
                            " Given a string, returns all possible permutations of comma delimited braced
                            " alternatives of that string.  pathogen#expand('/{a,b}/{c,d}') yields
                            " ['/a/c', '/a/d', '/b/c', '/b/d'].  Empty braces are treated as a wildcard
                            " and globbed.  Actual globs are preserved.
    1              0.000004 function! pathogen#expand(pattern) abort
                              if a:pattern =~# '{[^{}]\+}'
                                let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
                                let found = map(split(pat, ',', 1), 'pre.v:val.post')
                                let results = []
                                for pattern in found
                                  call extend(results, pathogen#expand(pattern))
                                endfor
                                return results
                              elseif a:pattern =~# '{}'
                                let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
                                let post = a:pattern[strlen(pat) : -1]
                                return map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
                              else
                                return [a:pattern]
                              endif
                            endfunction
                            
                            " \ on Windows unless shellslash is set, / everywhere else.
    1              0.000003 function! pathogen#slash() abort
                              return !exists("+shellslash") || &shellslash ? '/' : '\'
                            endfunction
                            
    1              0.000005 function! pathogen#separator() abort
                              return pathogen#slash()
                            endfunction
                            
                            " Convenience wrapper around glob() which returns a list.
    1              0.000004 function! pathogen#glob(pattern) abort
                              let files = split(glob(a:pattern),"\n")
                              return map(files,'substitute(v:val,"[".pathogen#slash()."/]$","","")')
                            endfunction "}}}1
                            
                            " Like pathogen#glob(), only limit the results to directories.
    1              0.000005 function! pathogen#glob_directories(pattern) abort
                              return filter(pathogen#glob(a:pattern),'isdirectory(v:val)')
                            endfunction "}}}1
                            
                            " Remove duplicates from a list.
    1              0.000004 function! pathogen#uniq(list) abort
                              let i = 0
                              let seen = {}
                              while i < len(a:list)
                                if (a:list[i] ==# '' && exists('empty')) || has_key(seen,a:list[i])
                                  call remove(a:list,i)
                                elseif a:list[i] ==# ''
                                  let i += 1
                                  let empty = 1
                                else
                                  let seen[a:list[i]] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:list
                            endfunction
                            
                            " Backport of fnameescape().
    1              0.000005 function! pathogen#fnameescape(string) abort
                              if exists('*fnameescape')
                                return fnameescape(a:string)
                              elseif a:string ==# '-'
                                return '\-'
                              else
                                return substitute(escape(a:string," \t\n*?[{`$\\%#'\"|!<"),'^[+>]','\\&','')
                              endif
                            endfunction
                            
                            " Like findfile(), but hardcoded to use the runtimepath.
    1              0.000006 function! pathogen#runtime_findfile(file,count) abort "{{{1
                              let rtp = pathogen#join(1,pathogen#split(&rtp))
                              let file = findfile(a:file,rtp,a:count)
                              if file ==# ''
                                return ''
                              else
                                return fnamemodify(file,':p')
                              endif
                            endfunction
                            
                            " Section: Deprecated
                            
    1              0.000009 function! s:warn(msg) abort
                              echohl WarningMsg
                              echomsg a:msg
                              echohl NONE
                            endfunction
                            
                            " Prepend all subdirectories of path to the rtp, and append all 'after'
                            " directories in those subdirectories.  Deprecated.
    1              0.000005 function! pathogen#runtime_prepend_subdirectories(path) abort
                              call s:warn('Change pathogen#runtime_prepend_subdirectories('.string(a:path).') to pathogen#infect('.string(a:path.'/{}').')')
                              return pathogen#surround(a:path . pathogen#slash() . '{}')
                            endfunction
                            
    1              0.000004 function! pathogen#incubate(...) abort
                              let name = a:0 ? a:1 : 'bundle/{}'
                              call s:warn('Change pathogen#incubate('.(a:0 ? string(a:1) : '').') to pathogen#infect('.string(name).')')
                              return pathogen#interpose(name)
                            endfunction
                            
                            " Deprecated alias for pathogen#interpose().
    1              0.000005 function! pathogen#runtime_append_all_bundles(...) abort
                              if a:0
                                call s:warn('Change pathogen#runtime_append_all_bundles('.string(a:1).') to pathogen#infect('.string(a:1.'/{}').')')
                              else
                                call s:warn('Change pathogen#runtime_append_all_bundles() to pathogen#infect()')
                              endif
                              return pathogen#interpose(a:0 ? a:1 . '/{}' : 'bundle/{}')
                            endfunction
                            
    1              0.000010 if exists(':Vedit')
                              finish
                            endif
                            
    1              0.000005 let s:vopen_warning = 0
                            
    1              0.000006 function! s:find(count,cmd,file,lcd)
                              let rtp = pathogen#join(1,pathogen#split(&runtimepath))
                              let file = pathogen#runtime_findfile(a:file,a:count)
                              if file ==# ''
                                return "echoerr 'E345: Can''t find file \"".a:file."\" in runtimepath'"
                              endif
                              if !s:vopen_warning
                                let s:vopen_warning = 1
                                let warning = '|echohl WarningMsg|echo "Install scriptease.vim to continue using :V'.a:cmd.'"|echohl NONE'
                              else
                                let warning = ''
                              endif
                              if a:lcd
                                let path = file[0:-strlen(a:file)-2]
                                execute 'lcd `=path`'
                                return a:cmd.' '.pathogen#fnameescape(a:file) . warning
                              else
                                return a:cmd.' '.pathogen#fnameescape(file) . warning
                              endif
                            endfunction
                            
    1              0.000005 function! s:Findcomplete(A,L,P)
                              let sep = pathogen#slash()
                              let cheats = {
                                    \'a': 'autoload',
                                    \'d': 'doc',
                                    \'f': 'ftplugin',
                                    \'i': 'indent',
                                    \'p': 'plugin',
                                    \'s': 'syntax'}
                              if a:A =~# '^\w[\\/]' && has_key(cheats,a:A[0])
                                let request = cheats[a:A[0]].a:A[1:-1]
                              else
                                let request = a:A
                              endif
                              let pattern = substitute(request,'/\|\'.sep,'*'.sep,'g').'*'
                              let found = {}
                              for path in pathogen#split(&runtimepath)
                                let path = expand(path, ':p')
                                let matches = split(glob(path.sep.pattern),"\n")
                                call map(matches,'isdirectory(v:val) ? v:val.sep : v:val')
                                call map(matches,'expand(v:val, ":p")[strlen(path)+1:-1]')
                                for match in matches
                                  let found[match] = 1
                                endfor
                              endfor
                              return sort(keys(found))
                            endfunction
                            
    1              0.000024 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Ve       :execute s:find(<count>,'edit<bang>',<q-args>,0)
    1              0.000018 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vedit    :execute s:find(<count>,'edit<bang>',<q-args>,0)
    1              0.000015 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vopen    :execute s:find(<count>,'edit<bang>',<q-args>,1)
    1              0.000015 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vsplit   :execute s:find(<count>,'split',<q-args>,<bang>1)
    1              0.000016 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vvsplit  :execute s:find(<count>,'vsplit',<q-args>,<bang>1)
    1              0.000021 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vtabedit :execute s:find(<count>,'tabedit',<q-args>,<bang>1)
    1              0.000015 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vpedit   :execute s:find(<count>,'pedit',<q-args>,<bang>1)
    1              0.000016 command! -bar -bang -range=1 -nargs=1 -complete=customlist,s:Findcomplete Vread    :execute s:find(<count>,'read',<q-args>,<bang>1)
                            
                            " vim:set et sw=2 foldmethod=expr foldexpr=getline(v\:lnum)=~'^\"\ Section\:'?'>1'\:getline(v\:lnum)=~#'^fu'?'a1'\:getline(v\:lnum)=~#'^endf'?'s1'\:'=':

SCRIPT  /usr/local/Cellar/macvim/7.4-76/MacVim.app/Contents/Resources/vim/runtime/ftoff.vim
Sourced 2 times
Total time:   0.005526
 Self time:   0.005526

count  total (s)   self (s)
                            " Vim support file to switch off detection of file types
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2001 Jun 11
                            
    2              0.000020 if exists("did_load_filetypes")
    2              0.000009   unlet did_load_filetypes
    2              0.000004 endif
                            
                            " Remove all autocommands in the filetypedetect group
    2              0.005466 silent! au! filetypedetect *

SCRIPT  /Users/Vishal/.vim_runtime/sources_non_forked/haskell-vim/ftdetect/haskell.vim
Sourced 1 time
Total time:   0.000151
 Self time:   0.000151

count  total (s)   self (s)

SCRIPT  /Users/Vishal/.vim_runtime/sources_non_forked/nginx-vim/ftdetect/nginx.vim
Sourced 1 time
Total time:   0.000280
 Self time:   0.000280

count  total (s)   self (s)
                            au BufRead,BufNewFile /etc/nginx/* set ft=nginx
    1              0.000074 au BufRead,BufNewFile /usr/local/nginx/conf/* set ft=nginx

SCRIPT  /Users/Vishal/.vim_runtime/sources_non_forked/vim-bundle-mako/ftdetect/mako.vim
Sourced 1 time
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)

SCRIPT  /Users/Vishal/.vim_runtime/sources_non_forked/vim-coffee-script/ftdetect/coffee.vim
Sourced 1 time
Total time:   0.000493
 Self time:   0.000493

count  total (s)   self (s)
                            " Language:    CoffeeScript
                            " Maintainer:  Mick Koch <mick@kochm.co>
                            " URL:         http://github.com/kchmck/vim-coffee-script
                            " License:     WTFPL
                            
    1              0.000171 autocmd BufNewFile,BufRead *.coffee set filetype=coffee
    1              0.000109 autocmd BufNewFile,BufRead *Cakefile set filetype=coffee
    1              0.000087 autocmd BufNewFile,BufRead *.coffeekup,*.ck set filetype=coffee
    1              0.000045 autocmd BufNewFile,BufRead *._coffee set filetype=coffee
                            
    1              0.000009 function! s:DetectCoffee()
                                if getline(1) =~ '^#!.*\<coffee\>'
                                    set filetype=coffee
                                endif
                            endfunction
                            
    1              0.000053 autocmd BufNewFile,BufRead * call s:DetectCoffee()

SCRIPT  /Users/Vishal/.vim_runtime/sources_non_forked/vim-go/ftdetect/gofiletype.vim
Sourced 1 time
Total time:   0.000248
 Self time:   0.000248

count  total (s)   self (s)
                            " We take care to preserve the user's fileencodings and fileformats,
                            " because those settings are global (not buffer local), yet we want
                            " to override them for loading Go files, which are defined to be UTF-8.
    1              0.000011 let s:current_fileformats = ''
    1              0.000003 let s:current_fileencodings = ''
                            
                            " define fileencodings to open as utf-8 encoding even if it's ascii.
    1              0.000009 function! s:gofiletype_pre()
                              let s:current_fileformats = &g:fileformats
                              let s:current_fileencodings = &g:fileencodings
                              set fileencodings=utf-8 fileformats=unix
                              setlocal filetype=go
                            endfunction
                            
                            " restore fileencodings as others
    1              0.000003 function! s:gofiletype_post()
                              let &g:fileformats = s:current_fileformats
                              let &g:fileencodings = s:current_fileencodings
                            endfunction
                            
    1              0.000092 au BufNewFile *.go setlocal filetype=go fileencoding=utf-8 fileformat=unix
    1              0.000080 au BufRead *.go call s:gofiletype_pre()
    1              0.000019 au BufReadPost *.go call s:gofiletype_post()

SCRIPT  /Users/Vishal/.vim_runtime/sources_non_forked/vim-less/ftdetect/less.vim
Sourced 1 time
Total time:   0.000194
 Self time:   0.000194

count  total (s)   self (s)

SCRIPT  /Users/Vishal/.vim_runtime/sources_non_forked/vim-markdown/ftdetect/markdown.vim
Sourced 1 time
Total time:   0.000278
 Self time:   0.000278

count  total (s)   self (s)

SCRIPT  /Users/Vishal/.vim_runtime/vimrcs/extended.vim
Sourced 1 time
Total time:   0.007761
 Self time:   0.001793

count  total (s)   self (s)
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Important: 
                            "       This requries that you install https://github.com/amix/vimrc !
                            "
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => GUI related
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Set font according to system
    1              0.000013 if has("mac") || has("macunix")
    1              0.000013     set gfn=Source\ Code\ Pro:h15,Menlo:h15
    1              0.000003 elseif has("win16") || has("win32")
                                set gfn=Source\ Code\ Pro:h12,Bitstream\ Vera\ Sans\ Mono:h11
                            elseif has("linux")
                                set gfn=Source\ Code\ Pro:h12,Bitstream\ Vera\ Sans\ Mono:h11
                            elseif has("unix")
                                set gfn=Monospace\ 11
                            endif
                            
                            " Open MacVim in fullscreen mode
    1              0.000004 if has("gui_macvim")
    1              0.000005     set fuoptions=maxvert,maxhorz
    1              0.000012     au GUIEnter * set fullscreen
    1              0.000001 endif
                            
                            " Disable scrollbars (real hackers don't use scrollbars for navigation!)
    1              0.000004 set guioptions-=r
    1              0.000002 set guioptions-=R
    1              0.000002 set guioptions-=l
    1              0.000003 set guioptions-=L
                            
                            " Colorscheme
    1              0.000005 if has("gui_running")
    1              0.000541     set background=dark
    1              0.000306     colorscheme peaksea
    1              0.000003 else
                                colorscheme desert
                                let g:colors_name="desert"
                            endif
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Fast editing and reloading of vimrc configs
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000020 map <leader>e :e! ~/.vim_runtime/my_configs.vim<cr>
    1              0.000013 autocmd! bufwritepost vimrc source ~/.vim_runtime/my_configs.vim
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Turn persistent undo on 
                            "    means that you can undo even when you close a buffer/VIM
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000002 try
    1              0.000008     set undodir=~/.vim_runtime/temp_dirs/undodir
    1              0.000004     set undofile
    1              0.000002 catch
                            endtry
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Command mode related
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " Smart mappings on the command line
    1              0.000006 cno $h e ~/
    1              0.000007 cno $d e ~/Desktop/
    1              0.000005 cno $j e ./
    1              0.000008 cno $c e <C-\>eCurrentFileDir("e")<cr>
                            
                            " $q is super useful when browsing on the command line
                            " it deletes everything until the last slash 
    1              0.000007 cno $q <C-\>eDeleteTillSlash()<cr>
                            
                            " Bash like keys for the command line
    1              0.000007 cnoremap <C-A>		<Home>
    1              0.000006 cnoremap <C-E>		<End>
    1              0.000005 cnoremap <C-K>		<C-U>
                            
    1              0.000006 cnoremap <C-P> <Up>
    1              0.000005 cnoremap <C-N> <Down>
                            
                            " Map ½ to something useful
    1              0.000006 map ½ $
    1              0.000004 cmap ½ $
    1              0.000005 imap ½ $
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Parenthesis/bracket
                            """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000009 vnoremap $1 <esc>`>a)<esc>`<i(<esc>
    1              0.000006 vnoremap $2 <esc>`>a]<esc>`<i[<esc>
    1              0.000006 vnoremap $3 <esc>`>a}<esc>`<i{<esc>
    1              0.000007 vnoremap $$ <esc>`>a"<esc>`<i"<esc>
    1              0.000006 vnoremap $q <esc>`>a'<esc>`<i'<esc>
    1              0.000006 vnoremap $e <esc>`>a"<esc>`<i"<esc>
                            
                            " Map auto complete of (, ", ', [
    1              0.000006 inoremap $1 ()<esc>i
    1              0.000005 inoremap $2 []<esc>i
    1              0.000009 inoremap $3 {}<esc>i
    1              0.000006 inoremap $4 {<esc>o}<esc>O
    1              0.000005 inoremap $q ''<esc>i
    1              0.000005 inoremap $e ""<esc>i
    1              0.000006 inoremap $t <><esc>i
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => General abbreviations
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000008 iab xdate <c-r>=strftime("%d/%m/%y %H:%M:%S")<cr>
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Omni complete functions
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000009 autocmd FileType css set omnifunc=csscomplete#CompleteCSS
                            
                            
                            
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
                            " => Helper functions
                            """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
    1              0.000005 func! DeleteTillSlash()
                                let g:cmd = getcmdline()
                            
                                if has("win16") || has("win32")
                                    let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\]\\).*", "\\1", "")
                                else
                                    let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*", "\\1", "")
                                endif
                            
                                if g:cmd == g:cmd_edited
                                    if has("win16") || has("win32")
                                        let g:cmd_edited = substitute(g:cmd, "\\(.*\[\\\\\]\\).*\[\\\\\]", "\\1", "")
                                    else
                                        let g:cmd_edited = substitute(g:cmd, "\\(.*\[/\]\\).*/", "\\1", "")
                                    endif
                                endif   
                            
                                return g:cmd_edited
                            endfunc
                            
    1              0.000290 func! CurrentFileDir(cmd)
                                return a:cmd . " " . expand("%:p:h") . "/"
                            endfunc

SCRIPT  /Users/Vishal/.vim_runtime/sources_forked/peaksea/colors/peaksea.vim
Sourced 1 time
Total time:   0.003692
 Self time:   0.003193

count  total (s)   self (s)
                            " Vim color file --- psc (peak sea color) "Lite version"
                            " Maintainer:	Pan, Shi Zhu <Go to the following URL for my email>
                            " URL:		http://vim.sourceforge.net/scripts/script.php?script_id=760
                            " Last Change:	5 Feb 2010
                            " Version:	3.4
                            "
                            "	Comments and e-mails are welcomed, thanks.
                            "
                            "	The peaksea color is simply a colorscheme with the default settings of
                            "	the original ps_color. Lite version means there's no custom settings
                            "	and fancy features such as integration with reloaded.vim 
                            "
                            "	The full version of ps_color.vim will be maintained until Vim 8.
                            "	By then there will be only the lite version: peaksea.vim
                            "
                            " Note: Please set the background option in your .vimrc and/or .gvimrc
                            "
                            "	It is much better *not* to set 'background' option inside
                            "	a colorscheme file.  because ":set background" improperly
                            "	may cause colorscheme be sourced twice
                            "
                            " Color Scheme Overview: 
                            "	:ru syntax/hitest.vim
                            "
                            " Relevant Help: 
                            "	:h highlight-groups
                            "	:h psc-cterm-color-table
                            "
                            " Colors Order:
                            "	#rrggbb
                            "
                            
    1              0.000653 hi clear
                            
    1              0.000004 if exists("syntax_on")
    1              0.000357   syntax reset
    1              0.000002 endif
                            
    1              0.000004 let g:colors_name = "peaksea"
                            
                            " I don't want to abuse folding, but here folding is used to avoid confusion. 
    1              0.000003 if &background=='light' 
                              " for background=light {{{2
                              " LIGHT COLOR DEFINE START
                            
                              hi Normal		guifg=#000000	guibg=#e0e0e0	gui=NONE
                              hi Search		guifg=White	guibg=DarkRed	gui=NONE
                              hi Visual		guifg=NONE	guibg=#a6caf0	gui=NONE
                              hi Cursor		guifg=#f0f0f0	guibg=#008000	gui=NONE
                              " The idea of CursorIM is pretty good, however, the feature is still buggy
                              " in the current version (Vim 7.0).
                              " The following line will be kept commented until the bug fixed.
                              "
                              " hi CursorIM		guifg=#f0f0f0	guibg=#800080
                              hi Special		guifg=#907000	guibg=NONE	gui=NONE
                              hi Comment		guifg=#606000	guibg=NONE	gui=NONE
                              hi Number		guifg=#907000	guibg=NONE	gui=NONE
                              hi Constant		guifg=#007068	guibg=NONE	gui=NONE
                              hi StatusLine		guifg=fg	guibg=#a6caf0	gui=NONE
                              hi LineNr		guifg=#686868	guibg=NONE	gui=NONE
                              hi Question		guifg=fg	guibg=#d0d090	gui=NONE
                              hi PreProc		guifg=#009030	guibg=NONE	gui=NONE
                              hi Statement		guifg=#2060a8	guibg=NONE	gui=NONE
                              hi Type		guifg=#0850a0	guibg=NONE	gui=NONE
                              hi Todo		guifg=#800000	guibg=#e0e090	gui=NONE
                              " NOTE THIS IS IN THE WARM SECTION
                              hi Error		guifg=#c03000	guibg=NONE	gui=NONE
                              hi Identifier		guifg=#a030a0	guibg=NONE	gui=NONE
                              hi ModeMsg		guifg=fg	guibg=#b0b0e0	gui=NONE
                              hi VisualNOS		guifg=fg	guibg=#b0b0e0	gui=NONE
                              hi SpecialKey		guifg=#1050a0	guibg=NONE	gui=NONE
                              hi NonText		guifg=#002090	guibg=#d0d0d0	gui=NONE
                              hi Directory		guifg=#a030a0	guibg=NONE	gui=NONE
                              hi ErrorMsg		guifg=fg	guibg=#f0b090	gui=NONE
                              hi MoreMsg		guifg=#489000	guibg=NONE	gui=NONE
                              hi Title		guifg=#a030a0	guibg=NONE	gui=NONE
                              hi WarningMsg		guifg=#b02000	guibg=NONE	gui=NONE
                              hi WildMenu		guifg=fg	guibg=#d0d090	gui=NONE
                              hi Folded		guifg=NONE	guibg=#b0e0b0	gui=NONE
                              hi FoldColumn		guifg=fg	guibg=#90e090	gui=NONE
                              hi DiffAdd		guifg=NONE	guibg=#b0b0e0	gui=NONE
                              hi DiffChange		guifg=NONE	guibg=#e0b0e0	gui=NONE
                              hi DiffDelete		guifg=#002090	guibg=#d0d0d0	gui=NONE
                              hi DiffText		guifg=NONE	guibg=#c0e080	gui=NONE
                              hi SignColumn		guifg=fg	guibg=#90e090	gui=NONE
                            
                              hi IncSearch		guifg=White	guibg=DarkRed	gui=NONE
                              hi StatusLineNC	guifg=fg	guibg=#c0c0c0	gui=NONE
                              hi VertSplit		guifg=fg	guibg=#c0c0c0	gui=NONE
                              hi Underlined		guifg=#6a5acd	guibg=NONE	gui=underline
                              hi Ignore		guifg=bg	guibg=NONE
                              " NOTE THIS IS IN THE WARM SECTION
                              if v:version >= 700
                                if has('spell')
                                  hi SpellBad	guifg=NONE	guibg=NONE	guisp=#c03000
                                  hi SpellCap	guifg=NONE	guibg=NONE	guisp=#2060a8
                                  hi SpellRare	guifg=NONE	guibg=NONE	guisp=#a030a0
                                  hi SpellLocal	guifg=NONE	guibg=NONE	guisp=#007068
                                endif
                                hi Pmenu		guifg=fg	guibg=#e0b0e0
                                hi PmenuSel		guifg=#f0f0f0	guibg=#806060	gui=NONE
                                hi PmenuSbar	guifg=fg	guibg=#c0c0c0	gui=NONE
                                hi PmenuThumb	guifg=fg	guibg=#c0e080	gui=NONE
                                hi TabLine		guifg=fg	guibg=#c0c0c0	gui=NONE
                                hi TabLineFill	guifg=fg	guibg=#c0c0c0	gui=NONE
                                hi TabLineSel	guifg=fg	guibg=NONE	gui=NONE
                                hi CursorColumn	guifg=NONE	guibg=#f0b090
                                hi CursorLine	guifg=NONE	guibg=NONE	gui=underline
                                hi MatchParen	guifg=NONE	guibg=#c0e080
                              endif
                            
                              " LIGHT COLOR DEFINE END
                            
                              " Vim 7 added stuffs
                              if v:version >= 700
                                hi Ignore		gui=NONE
                            
                                " the gui=undercurl guisp could only support in Vim 7
                                if has('spell')
                                  hi SpellBad	gui=undercurl
                                  hi SpellCap	gui=undercurl
                                  hi SpellRare	gui=undercurl
                                  hi SpellLocal	gui=undercurl
                                endif
                                hi TabLine		gui=underline
                                hi TabLineFill	gui=underline
                                hi CursorLine	gui=underline
                              endif
                            
                              " For reversed stuffs, clear the reversed prop and set the bold prop again
                              hi IncSearch		gui=bold
                              hi StatusLine		gui=bold
                              hi StatusLineNC	gui=bold
                              hi VertSplit		gui=bold
                              hi Visual		gui=bold
                            
                              " Enable the bold property
                              hi Question		gui=bold
                              hi DiffText		gui=bold
                              hi Statement		gui=bold
                              hi Type		gui=bold
                              hi MoreMsg		gui=bold
                              hi ModeMsg		gui=bold
                              hi NonText		gui=bold
                              hi Title		gui=bold
                              hi DiffDelete		gui=bold
                              hi TabLineSel		gui=bold
                            
                              " gui define for background=light end here
                            
                              " generally, a dumb terminal is dark, we assume the light terminal has 256
                              " color support.
                              if &t_Co==8 || &t_Co==16
                                set t_Co=256
                              endif
                              if &t_Co==256
                                " 256color light terminal support here
                            
                                hi Normal		ctermfg=16	ctermbg=254	cterm=NONE
                                " Comment/Uncomment the following line to disable/enable transparency
                                "hi Normal		ctermfg=16	ctermbg=NONE	cterm=NONE
                                hi Search		ctermfg=White	ctermbg=DarkRed	cterm=NONE
                                hi Visual		ctermfg=NONE	ctermbg=153	cterm=NONE
                                hi Cursor		ctermfg=255	ctermbg=28	cterm=NONE
                                " hi CursorIM	ctermfg=255	ctermbg=90
                                hi Special		ctermfg=94	ctermbg=NONE	cterm=NONE
                                hi Comment		ctermfg=58	ctermbg=NONE	cterm=NONE
                                hi Number		ctermfg=94	ctermbg=NONE	cterm=NONE
                                hi Constant		ctermfg=23	ctermbg=NONE	cterm=NONE
                                hi StatusLine	ctermfg=fg	ctermbg=153	cterm=NONE
                                hi LineNr		ctermfg=242	ctermbg=NONE	cterm=NONE
                                hi Question		ctermfg=fg	ctermbg=186	cterm=NONE
                                hi PreProc		ctermfg=29	ctermbg=NONE	cterm=NONE
                                hi Statement	ctermfg=25	ctermbg=NONE	cterm=NONE
                                hi Type		ctermfg=25	ctermbg=NONE	cterm=NONE
                                hi Todo		ctermfg=88	ctermbg=186	cterm=NONE
                                " NOTE THIS IS IN THE WARM SECTION
                                hi Error		ctermfg=130	ctermbg=NONE	cterm=NONE
                                hi Identifier	ctermfg=133	ctermbg=NONE	cterm=NONE
                                hi ModeMsg		ctermfg=fg	ctermbg=146	cterm=NONE
                                hi VisualNOS	ctermfg=fg	ctermbg=146	cterm=NONE
                                hi SpecialKey	ctermfg=25	ctermbg=NONE	cterm=NONE
                                hi NonText		ctermfg=18	ctermbg=252	cterm=NONE
                                " Comment/Uncomment the following line to disable/enable transparency
                                "hi NonText		ctermfg=18	ctermbg=NONE	cterm=NONE
                                hi Directory	ctermfg=133	ctermbg=NONE	cterm=NONE
                                hi ErrorMsg		ctermfg=fg	ctermbg=216	cterm=NONE
                                hi MoreMsg		ctermfg=64	ctermbg=NONE	cterm=NONE
                                hi Title		ctermfg=133	ctermbg=NONE	cterm=NONE
                                hi WarningMsg	ctermfg=124	ctermbg=NONE	cterm=NONE
                                hi WildMenu		ctermfg=fg	ctermbg=186	cterm=NONE
                                hi Folded		ctermfg=NONE	ctermbg=151	cterm=NONE
                                hi FoldColumn	ctermfg=fg	ctermbg=114	cterm=NONE
                                hi DiffAdd		ctermfg=NONE	ctermbg=146	cterm=NONE
                                hi DiffChange	ctermfg=NONE	ctermbg=182	cterm=NONE
                                hi DiffDelete	ctermfg=18	ctermbg=252	cterm=NONE
                                hi DiffText		ctermfg=NONE	ctermbg=150	cterm=NONE
                                hi SignColumn	ctermfg=fg	ctermbg=114	cterm=NONE
                            
                                hi IncSearch	ctermfg=White	ctermbg=DarkRed	cterm=NONE
                                hi StatusLineNC	ctermfg=fg	ctermbg=250	cterm=NONE
                                hi VertSplit	ctermfg=fg	ctermbg=250	cterm=NONE
                                hi Underlined	ctermfg=62	ctermbg=NONE	cterm=underline
                                hi Ignore		ctermfg=bg	ctermbg=NONE
                                " NOTE THIS IS IN THE WARM SECTION
                                if v:version >= 700
                                  if has('spell')
                                    if 0
                                      " ctermsp is not supported in Vim7, we ignore it.
                                      hi SpellBad	cterm=undercurl	ctermbg=NONE	ctermfg=130
                                      hi SpellCap	cterm=undercurl	ctermbg=NONE	ctermfg=25
                                      hi SpellRare	cterm=undercurl	ctermbg=NONE	ctermfg=133
                                      hi SpellLocal	cterm=undercurl	ctermbg=NONE	ctermfg=23
                                    else
                                      hi SpellBad	cterm=undercurl	ctermbg=NONE	ctermfg=NONE
                                      hi SpellCap	cterm=undercurl	ctermbg=NONE	ctermfg=NONE
                                      hi SpellRare	cterm=undercurl	ctermbg=NONE	ctermfg=NONE
                                      hi SpellLocal	cterm=undercurl	ctermbg=NONE	ctermfg=NONE
                                    endif
                                  endif
                                  hi Pmenu		ctermfg=fg	ctermbg=182
                                  hi PmenuSel	ctermfg=255	ctermbg=95	cterm=NONE
                                  hi PmenuSbar	ctermfg=fg	ctermbg=250	cterm=NONE
                                  hi PmenuThumb	ctermfg=fg	ctermbg=150	cterm=NONE
                                  hi TabLine	ctermfg=fg	ctermbg=250	cterm=NONE
                                  hi TabLineFill	ctermfg=fg	ctermbg=250	cterm=NONE
                                  hi TabLineSel	ctermfg=fg	ctermbg=NONE	cterm=NONE
                                  hi CursorColumn	ctermfg=NONE	ctermbg=216
                                  hi CursorLine	ctermfg=NONE	ctermbg=NONE	cterm=underline
                                  hi MatchParen	ctermfg=NONE	ctermbg=150
                                endif
                            
                                hi TabLine		cterm=underline
                                hi TabLineFill	cterm=underline
                                hi CursorLine	cterm=underline
                            
                                " For reversed stuffs, clear the reversed prop and set the bold prop again
                                hi IncSearch	cterm=bold
                                hi StatusLine	cterm=bold
                                hi StatusLineNC	cterm=bold
                                hi VertSplit	cterm=bold
                                hi Visual		cterm=bold
                            
                                hi NonText		cterm=bold
                                hi Question		cterm=bold
                                hi Title		cterm=bold
                                hi DiffDelete	cterm=bold
                                hi DiffText		cterm=bold
                                hi Statement	cterm=bold
                                hi Type		cterm=bold
                                hi MoreMsg		cterm=bold
                                hi ModeMsg		cterm=bold
                                hi TabLineSel	cterm=bold
                            
                                "hi lCursor		ctermfg=bg	ctermbg=fg	cterm=NONE
                              endif " t_Co==256
                              " }}}2
                            elseif &background=='dark' 
                              " for background=dark {{{2
                              " DARK COLOR DEFINE START
                            
    1              0.000048   hi Normal		guifg=#d0d0d0	guibg=#202020	gui=NONE
    1              0.000010   hi Comment		guifg=#d0d090	guibg=NONE	gui=NONE
    1              0.000007   hi Constant		guifg=#80c0e0	guibg=NONE	gui=NONE
    1              0.000007   hi Number		guifg=#e0c060	guibg=NONE	gui=NONE
    1              0.000007   hi Identifier		guifg=#f0c0f0	guibg=NONE	gui=NONE
    1              0.000007   hi Statement		guifg=#c0d8f8	guibg=NONE	gui=NONE
    1              0.000007   hi PreProc		guifg=#60f080	guibg=NONE	gui=NONE
    1              0.000007   hi Type		guifg=#b0d0f0	guibg=NONE	gui=NONE
    1              0.000007   hi Special		guifg=#e0c060	guibg=NONE	gui=NONE
    1              0.000006   hi Error		guifg=#f08060	guibg=NONE	gui=NONE
    1              0.000045   hi Todo		guifg=#800000	guibg=#d0d090	gui=NONE
    1              0.000017   hi Search		guifg=White	guibg=DarkRed	gui=NONE
    1              0.000011   hi Visual		guifg=#000000	guibg=#a6caf0	gui=NONE
    1              0.000010   hi Cursor		guifg=#000000	guibg=#00f000	gui=NONE
                              " NOTE THIS IS IN THE COOL SECTION
                              " hi CursorIM		guifg=#000000	guibg=#f000f0	gui=NONE
    1              0.000009   hi StatusLine		guifg=#000000	guibg=#a6caf0	gui=NONE
    1              0.000007   hi LineNr		guifg=#b0b0b0	guibg=NONE	gui=NONE
    1              0.000010   hi Question		guifg=#000000	guibg=#d0d090	gui=NONE
    1              0.000007   hi ModeMsg		guifg=fg	guibg=#000080	gui=NONE
    1              0.000014   hi VisualNOS		guifg=fg	guibg=#000080	gui=NONE
    1              0.000007   hi SpecialKey		guifg=#b0d0f0	guibg=NONE	gui=NONE
    1              0.000011   hi NonText		guifg=#202020	guibg=#202020	gui=NONE
    1              0.000006   hi Directory		guifg=#80c0e0	guibg=NONE	gui=NONE
    1              0.000010   hi ErrorMsg		guifg=#d0d090	guibg=#800000	gui=NONE
    1              0.000007   hi MoreMsg		guifg=#c0e080	guibg=NONE	gui=NONE
    1              0.000007   hi Title		guifg=#f0c0f0	guibg=NONE	gui=NONE
    1              0.000006   hi WarningMsg		guifg=#f08060	guibg=NONE	gui=NONE
    1              0.000009   hi WildMenu		guifg=#000000	guibg=#d0d090	gui=NONE
    1              0.000009   hi Folded		guifg=#aaaaaa	guibg=#333333	gui=NONE
    1              0.000012   hi FoldColumn		guifg=#202020	guibg=#202020	gui=NONE
    1              0.000007   hi DiffAdd		guifg=NONE	guibg=#000080	gui=NONE
    1              0.000007   hi DiffChange		guifg=NONE	guibg=#800080	gui=NONE
    1              0.000009   hi DiffDelete		guifg=#6080f0	guibg=#202020	gui=NONE
    1              0.000009   hi DiffText		guifg=#000000	guibg=#c0e080	gui=NONE
    1              0.000008   hi SignColumn		guifg=#e0e0e0	guibg=#202020	gui=NONE
    1              0.000008   hi IncSearch		guifg=White	guibg=DarkRed	gui=NONE
    1              0.000009   hi StatusLineNC	guifg=#000000	guibg=#c0c0c0	gui=NONE
    1              0.000012   hi VertSplit		guifg=#000000	guibg=#c0c0c0	gui=NONE
    1              0.000007   hi Underlined		guifg=#80a0ff	guibg=NONE	gui=underline 
    1              0.000006   hi Ignore		guifg=#000000	guibg=NONE
                              " NOTE THIS IS IN THE COOL SECTION
    1              0.000004   if v:version >= 700
    1              0.000006     if has('spell')
                                " the guisp= could only support in Vim 7
    1              0.000007       hi SpellBad	guifg=NONE	guibg=NONE	guisp=#f08060
    1              0.000006       hi SpellCap	guifg=NONE	guibg=NONE	guisp=#6080f0
    1              0.000007       hi SpellRare	guifg=NONE	guibg=NONE	guisp=#f0c0f0
    1              0.000007       hi SpellLocal	guifg=NONE	guibg=NONE	guisp=#c0d8f8
    1              0.000001     endif
                            
    1              0.000053     hi Pmenu          guifg=#dddddd     guibg=#444444     gui=NONE      ctermfg=NONE        ctermbg=NONE        cterm=NONE
    1              0.000012     hi PmenuSel       guifg=#000000     guibg=#ffffff     gui=NONE      ctermfg=NONE        ctermbg=NONE        cterm=NONE
                                
    1              0.000007     hi TabLine		guifg=fg	guibg=#008000	gui=NONE
    1              0.000007     hi TabLineFill	guifg=fg	guibg=#008000	gui=NONE
    1              0.000003     hi TabLineSel	guifg=fg	guibg=NONE	gui=NONE
    1              0.000007     hi CursorColumn	guifg=NONE	guibg=#800000	gui=NONE
    1              0.000004     hi CursorLine	guifg=NONE	guibg=NONE	gui=underline
    1              0.000010     hi MatchParen	guifg=NONE	guibg=#800080
    1              0.000001   endif
                            
                              " DARK COLOR DEFINE END
                            
                              " Vim 7 added stuffs
    1              0.000002   if v:version >= 700
    1              0.000002     hi Ignore	gui=NONE  
                            
                                " the gui=undercurl could only support in Vim 7
    1              0.000004     if has('spell')
    1              0.000003       hi SpellBad	gui=undercurl  
    1              0.000003       hi SpellCap	gui=undercurl  
    1              0.000002       hi SpellRare	gui=undercurl  
    1              0.000003       hi SpellLocal	gui=undercurl 
    1              0.000001     endif
    1              0.000002     hi TabLine		gui=underline  
    1              0.000003     hi TabLineFill	gui=underline  
    1              0.000002     hi Underlined	gui=underline  
    1              0.000002     hi CursorLine	gui=underline 
    1              0.000001   endif
                            
                              " gui define for background=dark end here
                            
    1              0.000003   if &t_Co==8 || &t_Co==16
                                " for 8-color and 16-color term
                                hi Normal		ctermfg=LightGrey   ctermbg=Black
                                hi Special		ctermfg=Yellow	    ctermbg=bg
                                hi Comment		ctermfg=DarkYellow  ctermbg=bg
                                hi Constant		ctermfg=Blue	    ctermbg=bg
                                hi Number		ctermfg=Yellow	    ctermbg=bg
                                hi LineNr		ctermfg=DarkGrey    ctermbg=bg
                                hi PreProc		ctermfg=Green	    ctermbg=bg
                                hi Statement	ctermfg=Cyan	    ctermbg=bg
                                hi Type		ctermfg=Cyan	    ctermbg=bg
                                hi Error		ctermfg=Red	    ctermbg=bg
                                hi Identifier	ctermfg=Magenta     ctermbg=bg
                                hi SpecialKey	ctermfg=Cyan	    ctermbg=bg
                                hi NonText		ctermfg=Blue	    ctermbg=bg
                                hi Directory	ctermfg=Blue	    ctermbg=bg
                                hi MoreMsg		ctermfg=Green	    ctermbg=bg
                                hi Title		ctermfg=Magenta     ctermbg=bg
                                hi WarningMsg	ctermfg=Red	    ctermbg=bg
                                hi DiffDelete	ctermfg=Blue	    ctermbg=bg
                            
                                hi Search		ctermfg=NONE	    ctermbg=DarkRed
                                hi Visual		ctermfg=Black	    ctermbg=DarkCyan
                                hi Cursor		ctermfg=Black	    ctermbg=Green
                                hi StatusLine	ctermfg=Black	    ctermbg=DarkCyan
                                hi Question		ctermfg=Black	    ctermbg=DarkYellow
                                hi Todo		ctermfg=DarkRed     ctermbg=DarkYellow
                                hi Folded		ctermfg=DarkGrey    ctermbg=DarkGrey
                                hi FoldColumn	ctermfg=DarkGrey    ctermbg=DarkGrey
                                hi ModeMsg		ctermfg=Grey	    ctermbg=DarkBlue
                                hi VisualNOS	ctermfg=Grey	    ctermbg=DarkBlue
                                hi ErrorMsg		ctermfg=DarkYellow  ctermbg=DarkRed
                                hi WildMenu		ctermfg=Black	    ctermbg=DarkYellow
                                hi SignColumn	ctermfg=White	    ctermbg=DarkGreen
                                hi DiffText		ctermfg=Black	    ctermbg=DarkYellow
                            
                                if v:version >= 700
                                  if has('spell')
                                    hi SpellBad	ctermfg=NONE	ctermbg=DarkRed
                                    hi SpellCap	ctermfg=NONE	ctermbg=DarkBlue
                                    hi SpellRare	ctermfg=NONE	ctermbg=DarkMagenta
                                    hi SpellLocal	ctermfg=NONE	ctermbg=DarkGreen
                                  endif
                            
                                  hi Pmenu		ctermfg=White	ctermbg=DarkGrey
                                  hi PmenuSel	ctermfg=Black	ctermbg=White
                            
                                  hi TabLine	ctermfg=fg	ctermbg=Black   	cterm=underline
                                  hi TabLineFill	ctermfg=fg	ctermbg=Black   	cterm=underline
                                  hi CursorColumn	ctermfg=NONE	ctermbg=DarkRed
                            
                                  hi TabLineSel	ctermfg=fg	ctermbg=bg
                                  hi CursorLine	ctermfg=NONE	ctermbg=bg		cterm=underline
                            
                                  hi MatchParen	ctermfg=NONE	ctermbg=DarkMagenta
                                endif
                                if &t_Co==8
                                  " 8 colour terminal support, this assumes 16 colour is available through
                                  " setting the 'bold' attribute, will get bright foreground colour.
                                  " However, the bright background color is not available for 8-color terms.
                                  "
                                  " You can manually set t_Co=16 in your .vimrc to see if your terminal
                                  " supports 16 colours, 
                                  hi DiffText	cterm=none  
                                  hi Visual		cterm=none  
                                  hi Cursor		cterm=none  
                                  hi Comment	cterm=none  
                                  hi Todo		cterm=none  
                                  hi StatusLine	cterm=none  
                                  hi Question	cterm=none  
                                  hi DiffChange	cterm=none  
                                  hi ModeMsg	cterm=none  
                                  hi VisualNOS	cterm=none  
                                  hi ErrorMsg	cterm=none  
                                  hi WildMenu	cterm=none  
                                  hi DiffAdd	cterm=none  
                                  hi Folded		cterm=none  
                                  hi DiffDelete	cterm=none  
                                  hi Normal		cterm=none  
                                  hi PmenuThumb	cterm=none 
                                  hi Search		cterm=bold  
                                  hi Special	cterm=bold  
                                  hi Constant	cterm=bold  
                                  hi Number		cterm=bold  
                                  hi LineNr		cterm=bold  
                                  hi PreProc	cterm=bold  
                                  hi Statement	cterm=bold  
                                  hi Type		cterm=bold  
                                  hi Error		cterm=bold  
                                  hi Identifier	cterm=bold  
                                  hi SpecialKey	cterm=bold  
                                  hi NonText	cterm=bold  
                                  hi MoreMsg	cterm=bold  
                                  hi Title		cterm=bold  
                                  hi WarningMsg	cterm=bold  
                                  hi FoldColumn	cterm=bold  
                                  hi SignColumn	cterm=bold  
                                  hi Directory	cterm=bold  
                                  hi DiffDelete	cterm=bold 
                                else
                                  " Background > 7 is only available with 16 or more colors
                            
                                  hi WarningMsg	cterm=none  
                                  hi Search		cterm=none  
                                  hi Visual		cterm=none  
                                  hi Cursor		cterm=none  
                                  hi Special	cterm=none  
                                  hi Comment	cterm=none  
                                  hi Constant	cterm=none  
                                  hi Number		cterm=none  
                                  hi LineNr		cterm=none  
                                  hi PreProc	cterm=none  
                                  hi Todo		cterm=none  
                                  hi Error		cterm=none  
                                  hi Identifier	cterm=none  
                                  hi Folded		cterm=none  
                                  hi SpecialKey	cterm=none  
                                  hi Directory	cterm=none  
                                  hi ErrorMsg	cterm=none  
                                  hi Normal		cterm=none  
                                  hi PmenuThumb	cterm=none 
                                  hi WildMenu	cterm=none  
                                  hi FoldColumn	cterm=none  
                                  hi SignColumn	cterm=none  
                                  hi DiffAdd	cterm=none  
                                  hi DiffChange	cterm=none  
                                  hi Question	cterm=none  
                                  hi StatusLine	cterm=none  
                                  hi DiffText	cterm=none 
                                  hi IncSearch	cterm=reverse  
                                  hi StatusLineNC	cterm=reverse  
                                  hi VertSplit	cterm=reverse 
                            
                                  " Well, well, bold font with color 0-7 is not possible.
                                  " So, the Question, StatusLine, DiffText cannot act as expected.
                            
                                  hi Statement	cterm=none  
                                  hi Type		cterm=none  
                                  hi MoreMsg	cterm=none  
                                  hi ModeMsg	cterm=none  
                                  hi NonText	cterm=none  
                                  hi Title		cterm=none  
                                  hi VisualNOS	cterm=none  
                                  hi DiffDelete	cterm=none  
                                  hi TabLineSel	cterm=none 
                            
                                endif
                              elseif &t_Co==256
                                " 256color dark terminal support here
    1              0.000006     hi Normal		ctermfg=252	ctermbg=234	cterm=NONE
                                " Comment/Uncomment the following line to disable/enable transparency
                                "hi Normal		ctermfg=252	ctermbg=NONE	cterm=NONE
    1              0.000004     hi Comment		ctermfg=186	ctermbg=NONE	cterm=NONE
    1              0.000004     hi Constant		ctermfg=110	ctermbg=NONE	cterm=NONE
    1              0.000004     hi Number		ctermfg=179	ctermbg=NONE	cterm=NONE
    1              0.000004     hi Identifier	ctermfg=219	ctermbg=NONE	cterm=NONE
    1              0.000003     hi Statement	ctermfg=153	ctermbg=NONE	cterm=NONE
    1              0.000004     hi PreProc		ctermfg=84	ctermbg=NONE	cterm=NONE
    1              0.000004     hi Type		ctermfg=153	ctermbg=NONE	cterm=NONE
    1              0.000003     hi Special		ctermfg=179	ctermbg=NONE	cterm=NONE
    1              0.000004     hi Error		ctermfg=209	ctermbg=NONE	cterm=NONE
    1              0.000003     hi Todo		ctermfg=88	ctermbg=186	cterm=NONE
    1              0.000005     hi Search		ctermfg=White	ctermbg=DarkRed	cterm=NONE
    1              0.000004     hi Visual		ctermfg=16	ctermbg=153	cterm=NONE
    1              0.000004     hi Cursor		ctermfg=16	ctermbg=46	cterm=NONE
                                " NOTE THIS IS IN THE COOL SECTION
                                " hi CursorIM	ctermfg=16	ctermbg=201	cterm=NONE
    1              0.000004     hi StatusLine	ctermfg=16	ctermbg=153	cterm=NONE
    1              0.000004     hi LineNr		ctermfg=249	ctermbg=NONE	cterm=NONE
    1              0.000004     hi Question		ctermfg=16	ctermbg=186	cterm=NONE
    1              0.000004     hi ModeMsg		ctermfg=fg	ctermbg=18	cterm=NONE
    1              0.000004     hi VisualNOS	ctermfg=fg	ctermbg=18	cterm=NONE
    1              0.000004     hi SpecialKey	ctermfg=153	ctermbg=NONE	cterm=NONE
    1              0.000004     hi NonText		ctermfg=69	ctermbg=233	cterm=NONE
                                " Comment/Uncomment the following line to disable/enable transparency
                                "hi NonText		ctermfg=69	ctermbg=NONE	cterm=NONE
    1              0.000003     hi Directory	ctermfg=110	ctermbg=NONE	cterm=NONE
    1              0.000004     hi ErrorMsg		ctermfg=186	ctermbg=88	cterm=NONE
    1              0.000004     hi MoreMsg		ctermfg=150	ctermbg=NONE	cterm=NONE
    1              0.000004     hi Title		ctermfg=219	ctermbg=NONE	cterm=NONE
    1              0.000003     hi WarningMsg	ctermfg=209	ctermbg=NONE	cterm=NONE
    1              0.000003     hi WildMenu		ctermfg=16	ctermbg=186	cterm=NONE
    1              0.000005     hi Folded		ctermfg=NONE	ctermbg=DarkGrey cterm=NONE
    1              0.000004     hi FoldColumn	ctermfg=DarkGrey ctermbg=DarkGrey cterm=NONE
    1              0.000005     hi DiffAdd		ctermfg=NONE	ctermbg=18	cterm=NONE
    1              0.000004     hi DiffChange	ctermfg=NONE	ctermbg=90	cterm=NONE
    1              0.000004     hi DiffDelete	ctermfg=69	ctermbg=234	cterm=NONE
    1              0.000006     hi DiffText		ctermfg=16	ctermbg=150	cterm=NONE
    1              0.000003     hi SignColumn	ctermfg=254	ctermbg=28	cterm=NONE
    1              0.000005     hi IncSearch	ctermfg=White	ctermbg=DarkRed	cterm=NONE
    1              0.000004     hi StatusLineNC	ctermfg=16	ctermbg=250	cterm=NONE
    1              0.000004     hi VertSplit	ctermfg=16	ctermbg=250	cterm=NONE
    1              0.000005     hi Underlined	ctermfg=111	ctermbg=NONE	cterm=underline 
    1              0.000003     hi Ignore		ctermfg=16	ctermbg=NONE
                                " NOTE THIS IS IN THE COOL SECTION
    1              0.000002     if v:version >= 700
    1              0.000005       if has('spell')
                                    " the ctermsp= is not supported in Vim 7 we simply ignored
    1              0.000002         if 0
                                      hi SpellBad	cterm=undercurl	ctermbg=NONE	ctermfg=209
                                      hi SpellCap	cterm=undercurl	ctermbg=NONE	ctermfg=69
                                      hi SpellRare	cterm=undercurl	ctermbg=NONE	ctermfg=219
                                      hi SpellLocal	cterm=undercurl	ctermbg=NONE	ctermfg=153
                                    else
    1              0.000005           hi SpellBad	cterm=undercurl	ctermbg=NONE	ctermfg=NONE
    1              0.000003           hi SpellCap	cterm=undercurl	ctermbg=NONE	ctermfg=NONE
    1              0.000004           hi SpellRare	cterm=undercurl	ctermbg=NONE	ctermfg=NONE
    1              0.000004           hi SpellLocal	cterm=undercurl	ctermbg=NONE	ctermfg=NONE
    1              0.000002         endif
    1              0.000001       endif
                            
    1              0.000004       hi Pmenu		ctermfg=White	ctermbg=DarkGrey
    1              0.000005       hi PmenuSel	ctermfg=Black	ctermbg=White	cterm=NONE
                            
    1              0.000004       hi TabLine	ctermfg=fg	ctermbg=Black	cterm=NONE
    1              0.000003       hi TabLineFill	ctermfg=fg	ctermbg=Black	cterm=NONE
    1              0.000004       hi TabLineSel	ctermfg=fg	ctermbg=NONE	cterm=NONE
                            
    1              0.000005       hi CursorColumn	ctermfg=NONE	ctermbg=88	cterm=NONE
    1              0.000003       hi CursorLine	ctermfg=NONE	ctermbg=NONE	cterm=underline
    1              0.000004       hi MatchParen	ctermfg=NONE	ctermbg=90
    1              0.000003       hi TabLine	cterm=underline  
    1              0.000003       hi TabLineFill	cterm=underline  
    1              0.000003       hi Underlined	cterm=underline  
    1              0.000002       hi CursorLine	cterm=underline 
    1              0.000002     endif
                            
    1              0.000002   endif " t_Co
                            
                              " }}}2
    1              0.000002 endif
                            
                            " Links:
                            "
                            " COLOR LINKS DEFINE START
                            
    1              0.000003 hi link		String		Constant
                            " Character must be different from strings because in many languages
                            " (especially C, C++) a 'char' variable is scalar while 'string' is pointer,
                            " mistaken a 'char' for a 'string' will cause disaster!
    1              0.000002 hi link		Character	Number
    1              0.000002 hi link		SpecialChar	LineNr
    1              0.000003 hi link		Tag		Identifier
    1              0.000003 hi link		cCppOut		LineNr
                            " The following are not standard hi links, 
                            " these are used by DrChip
    1              0.000003 hi link		Warning		MoreMsg
    1              0.000003 hi link		Notice		Constant
                            " these are used by Calendar
    1              0.000003 hi link		CalToday	PreProc
                            " these are used by TagList
    1              0.000004 hi link		MyTagListTagName	IncSearch
    1              0.000003 hi link		MyTagListTagScope	Constant
                            
    1              0.000021 hi TabLineFill guifg=#9098a0 guibg=#111111
    1              0.000012 hi TabLine guifg=black guibg=#888888
    1              0.000012 hi TabLineSel guifg=white guibg=#202020 gui=bold
                            
                            " COLOR LINKS DEFINE END
                            
                            " vim:et:nosta:sw=2:ts=8:
                            " vim600:fdm=marker:fdl=1:

SCRIPT  /Users/Vishal/.vim_runtime/my_configs.vim
Sourced 1 time
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
                            nmap <leader>bn :bnext<CR>
    1              0.000026 let $PATH = '/Users/Vishal/Library/Haskell/bin:/usr/local/go/bin:/Users/Vishal/.rbenv/shims:/usr/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/X11/bin:/usr/local/CrossPack-AVR/bin:/usr/local/MacGPG2/bin:/usr/texbin'

FUNCTION  <SNR>5_BMShow()
Called 1 time
Total time:   0.001443
 Self time:   0.000871

count  total (s)   self (s)
    1              0.000003   let s:bmenu_wait = 1
    1              0.000002   let s:bmenu_short = 1
    1              0.000001   let s:bmenu_count = 0
                              "
                              " get new priority, if exists
    1              0.000002   if a:0 == 1
                                let g:bmenu_priority = a:1
                              endif
                            
                              " remove old menu, if exists; keep one entry to avoid a torn off menu to
                              " disappear.
    1              0.000008   silent! unmenu &Buffers
    1              0.000012   exe 'noremenu ' . g:bmenu_priority . ".1 &Buffers.Dummy l"
    1              0.000003   silent! unmenu! &Buffers
                            
                              " create new menu; set 'cpo' to include the <CR>
    1              0.000010   let cpo_save = &cpo
    1              0.000008   set cpo&vim
    1              0.000014   exe 'an <silent> ' . g:bmenu_priority . ".2 &Buffers.&Refresh\\ menu :call <SID>BMShow()<CR>"
    1              0.000011   exe 'an ' . g:bmenu_priority . ".4 &Buffers.&Delete :confirm bd<CR>"
    1              0.000009   exe 'an ' . g:bmenu_priority . ".6 &Buffers.&Alternate :confirm b #<CR>"
    1              0.000011   exe 'an ' . g:bmenu_priority . ".7 &Buffers.&Next :confirm bnext<CR>"
    1              0.000009   exe 'an ' . g:bmenu_priority . ".8 &Buffers.&Previous :confirm bprev<CR>"
    1              0.000008   exe 'an ' . g:bmenu_priority . ".9 &Buffers.-SEP- :"
    1              0.000006   let &cpo = cpo_save
    1              0.000002   unmenu &Buffers.Dummy
                            
                              " figure out how many buffers there are
    1              0.000002   let buf = 1
    2              0.000006   while buf <= bufnr('$')
    1              0.000025     if bufexists(buf) && !isdirectory(bufname(buf)) && buflisted(buf)
    1              0.000003       let s:bmenu_count = s:bmenu_count + 1
    1              0.000001     endif
    1              0.000002     let buf = buf + 1
    1              0.000001   endwhile
    1              0.000002   if s:bmenu_count <= &menuitems
    1              0.000002     let s:bmenu_short = 0
    1              0.000001   endif
                            
                              " iterate through buffer list, adding each buffer to the menu:
    1              0.000001   let buf = 1
    2              0.000004   while buf <= bufnr('$')
    1              0.000008     if bufexists(buf) && !isdirectory(bufname(buf)) && buflisted(buf)
    1   0.000584   0.000012       call <SID>BMFilename(bufname(buf), buf)
    1              0.000001     endif
    1              0.000002     let buf = buf + 1
    1              0.000001   endwhile
    1              0.000001   let s:bmenu_wait = 0
    1              0.000001   aug buffer_list
    1              0.000611   au!
    1              0.000016   au BufCreate,BufFilePost * call <SID>BMAdd()
    1              0.000005   au BufDelete,BufFilePre * call <SID>BMRemove()
    1              0.000002   aug END

FUNCTION  pathogen#expand()
Called 4 times
Total time:   0.005291
 Self time:   0.005291

count  total (s)   self (s)
    4              0.000087   if a:pattern =~# '{[^{}]\+}'
                                let [pre, pat, post] = split(substitute(a:pattern, '\(.\{-\}\){\([^{}]\+\)}\(.*\)', "\\1\001\\2\001\\3", ''), "\001", 1)
                                let found = map(split(pat, ',', 1), 'pre.v:val.post')
                                let results = []
                                for pattern in found
                                  call extend(results, pathogen#expand(pattern))
                                endfor
                                return results
                              elseif a:pattern =~# '{}'
    4              0.000110     let pat = matchstr(a:pattern, '^.*{}[^*]*\%($\|[\\/]\)')
    4              0.000061     let post = a:pattern[strlen(pat) : -1]
    4              0.004907     return map(split(glob(substitute(pat, '{}', '*', 'g')), "\n"), 'v:val.post')
                              else
                                return [a:pattern]
                              endif

FUNCTION  pathogen#fnameescape()
Called 24 times
Total time:   0.000770
 Self time:   0.000770

count  total (s)   self (s)
   24              0.000166   if exists('*fnameescape')
   24              0.000524     return fnameescape(a:string)
                              elseif a:string ==# '-'
                                return '\-'
                              else
                                return substitute(escape(a:string," \t\n*?[{`$\\%#'\"|!<"),'^[+>]','\\&','')
                              endif

FUNCTION  pathogen#helptags()
Called 1 time
Total time:   0.072491
 Self time:   0.070705

count  total (s)   self (s)
    1   0.000010   0.000005   let sep = pathogen#slash()
   59   0.001202   0.000191   for glob in pathogen#split(&rtp)
  113              0.004304     for dir in map(split(glob(glob), "\n"), 'v:val.sep."/doc/".sep')
   55              0.015413       if (dir)[0 : strlen($VIMRUNTIME)] !=# $VIMRUNTIME.sep && filewritable(dir) == 2 && !empty(split(glob(dir.'*.txt'))) && (!filereadable(dir.'tags') || filewritable(dir.'tags'))
   24   0.049848   0.049078         silent! execute 'helptags' pathogen#fnameescape(dir)
   24              0.000167       endif
   55              0.000097     endfor
   58              0.000061   endfor

FUNCTION  pathogen#is_disabled()
Called 54 times
Total time:   0.003335
 Self time:   0.002337

count  total (s)   self (s)
   54              0.000313   if a:path =~# '\~$'
                                return 1
                              endif
   54   0.000586   0.000306   let sep = pathogen#slash()
   54   0.001640   0.000922   let blacklist = map( get(g:, 'pathogen_blacklist', get(g:, 'pathogen_disabled', [])) + pathogen#split($VIMBLACKLIST), 'substitute(v:val, "[\\/]$", "", "")')
   54              0.000531   return index(blacklist, fnamemodify(a:path, ':t')) != -1 || index(blacklist, a:path) != -1

FUNCTION  pathogen#surround()
Called 2 times
Total time:   0.012851
 Self time:   0.001009

count  total (s)   self (s)
    2   0.000033   0.000018   let sep = pathogen#slash()
    2   0.000643   0.000025   let rtp = pathogen#split(&rtp)
    2              0.000045   let path = fnamemodify(a:path, ':p:?[\\/]\=$??')
    2   0.007579   0.000318   let before = filter(pathogen#expand(path), '!pathogen#is_disabled(v:val)')
    2   0.001321   0.000077   let after = filter(reverse(pathogen#expand(path.sep.'after')), '!pathogen#is_disabled(v:val[0:-7])')
    2              0.000471   call filter(rtp, 'index(before + after, v:val) == -1')
    2   0.002746   0.000042   let &rtp = pathogen#join(before, rtp, after)
    2              0.000008   return &rtp

FUNCTION  <SNR>5_BMFilename()
Called 1 time
Total time:   0.000572
 Self time:   0.000078

count  total (s)   self (s)
    1              0.000006   if isdirectory(a:name)
                                return
                              endif
    1   0.000455   0.000010   let munge = <SID>BMMunge(a:name, a:num)
    1   0.000058   0.000009   let hash = <SID>BMHash(munge)
    1              0.000001   if s:bmenu_short == 0
    1              0.000006     let name = 'an ' . g:bmenu_priority . '.' . hash . ' &Buffers.' . munge
    1              0.000001   else
                                let name = 'an ' . g:bmenu_priority . '.' . hash . '.' . hash . ' &Buffers.' . <SID>BMHash2(munge) . munge
                              endif
                              " set 'cpo' to include the <CR>
    1              0.000005   let cpo_save = &cpo
    1              0.000006   set cpo&vim
    1              0.000016   exe name . ' :confirm b' . a:num . '<CR>'
    1              0.000006   let &cpo = cpo_save

FUNCTION  pathogen#split()
Called 57 times
Total time:   0.002347
 Self time:   0.002347

count  total (s)   self (s)
   57              0.000446   if type(a:path) == type([]) | return a:path | endif
   57              0.000253   if empty(a:path) | return [] | endif
    3              0.001064   let split = split(a:path,'\\\@<!\%(\\\\\)*\zs,')
    3              0.000520   return map(split,'substitute(v:val,''\\\([\\,]\)'',''\1'',"g")')

FUNCTION  pathogen#slash()
Called 57 times
Total time:   0.000300
 Self time:   0.000300

count  total (s)   self (s)
   57              0.000258   return !exists("+shellslash") || &shellslash ? '/' : '\'

FUNCTION  <SNR>5_BMTruncName()
Called 1 time
Total time:   0.000370
 Self time:   0.000370

count  total (s)   self (s)
    1              0.000002   let name = a:fname
    1              0.000002   if g:bmenu_max_pathlen < 5
                                let name = ""
                              else
    1              0.000003     let len = strlen(name)
    1              0.000002     if len > g:bmenu_max_pathlen
    1              0.000003       let amountl = (g:bmenu_max_pathlen / 2) - 2
    1              0.000002       let amountr = g:bmenu_max_pathlen - amountl - 3
    1              0.000005       let pattern = '^\(.\{,' . amountl . '}\).\{-}\(.\{,' . amountr . '}\)$'
    1              0.000177       let left = substitute(name, pattern, '\1', '')
    1              0.000156       let right = substitute(name, pattern, '\2', '')
    1              0.000005       if strlen(left) + strlen(right) < len
    1              0.000004 	let name = left . '...' . right
    1              0.000001       endif
    1              0.000001     endif
    1              0.000001   endif
    1              0.000002   return name

FUNCTION  <SNR>5_BMHash()
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
                              " Make name all upper case, so that chars are between 32 and 96
    1              0.000016   let nm = substitute(a:name, ".*", '\U\0', "")
    1              0.000004   if has("ebcdic")
                                " HACK: Replace all non alphabetics with 'Z'
                                "       Just to make it work for now.
                                let nm = substitute(nm, "[^A-Z]", 'Z', "g")
                                let sp = char2nr('A') - 1
                              else
    1              0.000002     let sp = char2nr(' ')
    1              0.000000   endif
                              " convert first six chars into a number for sorting:
    1              0.000016   return (char2nr(nm[0]) - sp) * 0x800000 + (char2nr(nm[1]) - sp) * 0x20000 + (char2nr(nm[2]) - sp) * 0x1000 + (char2nr(nm[3]) - sp) * 0x80 + (char2nr(nm[4]) - sp) * 0x20 + (char2nr(nm[5]) - sp)

FUNCTION  pathogen#infect()
Called 2 times
Total time:   0.081245
 Self time:   0.000342

count  total (s)   self (s)
    4              0.000052   for path in a:0 ? filter(reverse(copy(a:000)), 'type(v:val) == type("")') : ['bundle/{}']
    2              0.000064     if path =~# '^\%({\=[$~\\/]\|{\=\w:[\\/]\).*[{}*]'
    2   0.012903   0.000052       call pathogen#surround(path)
    2              0.000004     elseif path =~# '^\%([$~\\/]\|\w:[\\/]\)'
                                  call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
                                  call pathogen#surround(path . '/{}')
                                elseif path =~# '[{}*]'
                                  call pathogen#interpose(path)
                                else
                                  call s:warn('Change pathogen#infect('.string(path).') to pathogen#infect('.string(path.'/{}').')')
                                  call pathogen#interpose(path . '/{}')
                                endif
    2              0.000002   endfor
    2   0.067954   0.000023   call pathogen#cycle_filetype()
    2   0.000145   0.000024   if pathogen#is_disabled($MYVIMRC)
                                return 'finish'
                              endif
    2              0.000002   return ''

FUNCTION  pathogen#join()
Called 2 times
Total time:   0.002704
 Self time:   0.002704

count  total (s)   self (s)
    2              0.000009   if type(a:1) == type(1) && a:1
                                let i = 1
                                let space = ' '
                              else
    2              0.000005     let i = 0
    2              0.000005     let space = ''
    2              0.000002   endif
    2              0.000044   let path = ""
    8              0.000022   while i < a:0
    6              0.000064     if type(a:000[i]) == type([])
    6              0.000022       let list = a:000[i]
    6              0.000010       let j = 0
   77              0.000165       while j < len(list)
   71              0.001610         let escaped = substitute(list[j],'[,'.space.']\|\\[\,'.space.']\@=','\\&','g')
   71              0.000325         let path .= ',' . escaped
   71              0.000107         let j += 1
   71              0.000080       endwhile
    6              0.000005     else
                                  let path .= "," . a:000[i]
                                endif
    6              0.000011     let i += 1
    6              0.000006   endwhile
    2              0.000023   return substitute(path,'^,','','')

FUNCTION  pathogen#cycle_filetype()
Called 2 times
Total time:   0.067931
 Self time:   0.002287

count  total (s)   self (s)
    2              0.000010   if exists('g:did_load_filetypes')
    2   0.006760   0.001180     filetype off
    2   0.061153   0.001089     filetype on
    2              0.000003   endif

FUNCTION  <SNR>5_BMMunge()
Called 1 time
Total time:   0.000445
 Self time:   0.000075

count  total (s)   self (s)
    1              0.000002   let name = a:fname
    1              0.000002   if name == ''
                                if !exists("g:menutrans_no_file")
                                  let g:menutrans_no_file = "[No file]"
                                endif
                                let name = g:menutrans_no_file
                              else
    1              0.000011     let name = fnamemodify(name, ':p:~')
    1              0.000001   endif
                              " detach file name and separate it out:
    1              0.000004   let name2 = fnamemodify(name, ':t')
    1              0.000002   if a:bnum >= 0
    1              0.000004     let name2 = name2 . ' (' . a:bnum . ')'
    1              0.000001   endif
    1   0.000387   0.000017   let name = name2 . "\t" . <SID>BMTruncName(fnamemodify(name,':h'))
    1              0.000007   let name = escape(name, "\\. \t|")
    1              0.000007   let name = substitute(name, "&", "&&", "g")
    1              0.000005   let name = substitute(name, "\n", "^@", "g")
    1              0.000001   return name

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   0.081245   0.000342  pathogen#infect()
    1   0.072491   0.070705  pathogen#helptags()
    2   0.067931   0.002287  pathogen#cycle_filetype()
    2   0.012851   0.001009  pathogen#surround()
    4   0.005291             pathogen#expand()
   54   0.003335   0.002337  pathogen#is_disabled()
    2   0.002704             pathogen#join()
   57   0.002347             pathogen#split()
    1   0.001443   0.000871  <SNR>5_BMShow()
   24   0.000770             pathogen#fnameescape()
    1   0.000572   0.000078  <SNR>5_BMFilename()
    1   0.000445   0.000075  <SNR>5_BMMunge()
    1   0.000370             <SNR>5_BMTruncName()
   57   0.000300             pathogen#slash()
    1   0.000049             <SNR>5_BMHash()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    1   0.072491   0.070705  pathogen#helptags()
    4              0.005291  pathogen#expand()
    2              0.002704  pathogen#join()
   57              0.002347  pathogen#split()
   54   0.003335   0.002337  pathogen#is_disabled()
    2   0.067931   0.002287  pathogen#cycle_filetype()
    2   0.012851   0.001009  pathogen#surround()
    1   0.001443   0.000871  <SNR>5_BMShow()
   24              0.000770  pathogen#fnameescape()
    1              0.000370  <SNR>5_BMTruncName()
    2   0.081245   0.000342  pathogen#infect()
   57              0.000300  pathogen#slash()
    1   0.000572   0.000078  <SNR>5_BMFilename()
    1   0.000445   0.000075  <SNR>5_BMMunge()
    1              0.000049  <SNR>5_BMHash()

